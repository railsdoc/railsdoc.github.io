---
title: ActiveRecord::Persistence::ClassMethods
layout: default
---
<div class="main">
    <div class="banner">
        
            <span>Ruby on Rails 7.1.0</span><br />
        
        <div class="type">Module</div>
        <h1>
            ActiveRecord::Persistence::ClassMethods
            
        </h1>
        <ul class="files">
            
            <li><a href="../../../files/activerecord/lib/active_record/persistence_rb.html">activerecord/lib/active_record/persistence.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
  

  

  
  


  

  
    <h2 id="methods">Methods</h2>
    <ul>
      
        <li>
          <a href="#method-i-build">build</a>
        </li>
      
        <li>
          <a href="#method-i-create">create</a>
        </li>
      
        <li>
          <a href="#method-i-create-21">create!</a>
        </li>
      
        <li>
          <a href="#method-i-delete">delete</a>
        </li>
      
        <li>
          <a href="#method-i-destroy">destroy</a>
        </li>
      
        <li>
          <a href="#method-i-insert">insert</a>
        </li>
      
        <li>
          <a href="#method-i-insert-21">insert!</a>
        </li>
      
        <li>
          <a href="#method-i-insert_all">insert_all</a>
        </li>
      
        <li>
          <a href="#method-i-insert_all-21">insert_all!</a>
        </li>
      
        <li>
          <a href="#method-i-instantiate">instantiate</a>
        </li>
      
        <li>
          <a href="#method-i-query_constraints">query_constraints</a>
        </li>
      
        <li>
          <a href="#method-i-update">update</a>
        </li>
      
        <li>
          <a href="#method-i-update-21">update!</a>
        </li>
      
        <li>
          <a href="#method-i-upsert">upsert</a>
        </li>
      
        <li>
          <a href="#method-i-upsert_all">upsert_all</a>
        </li>
      
    </ul>
  

  

  
    

    

    

    

    <!-- Methods -->
    
    
      <h2 id="instance-public-methods">Instance Public methods</h2>
      
        <div class="method">
          <h3 id="method-i-build">
            
              build(attributes = nil, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Builds an object (or multiple objects) and returns either the built object or a list of built objects.</p>

<p>The <code>attributes</code> parameter can be either a <a href="../../Hash.html"><code>Hash</code></a> or an <a href="../../Array.html"><code>Array</code></a> of Hashes. These Hashes describe the attributes on the objects that are to be built.</p>

<h4 id="method-i-build-label-Examples">Examples</h4>

<pre><code># Build a single new object
User.build(first_name: &#39;Jamie&#39;)

# Build an Array of new objects
User.build([{ first_name: &#39;Jamie&#39; }, { first_name: &#39;Jeremy&#39; }])

# Build a single object and pass it into a block to set other attributes.
User.build(first_name: &#39;Jamie&#39;) do |u|
  u.is_admin = false
end

# Building an Array of new objects using a block, where the block is executed for each object:
User.build([{ first_name: &#39;Jamie&#39; }, { first_name: &#39;Jeremy&#39; }]) do |u|
  u.is_admin = false
end
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 82
      def build(attributes = nil, &amp;block)
        if attributes.is_a?(Array)
          attributes.collect { |attr| build(attr, &amp;block) }
        else
          new(attributes, &amp;block)
        end
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L82" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-create">
            
              create(attributes = nil, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Creates an object (or multiple objects) and saves it to the database, if validations pass. The resulting object is returned whether the object was saved successfully to the database or not.</p>

<p>The <code>attributes</code> parameter can be either a <a href="../../Hash.html"><code>Hash</code></a> or an <a href="../../Array.html"><code>Array</code></a> of Hashes. These Hashes describe the attributes on the objects that are to be created.</p>

<h4 id="method-i-create-label-Examples">Examples</h4>

<pre><code># Create a single new object
User.create(first_name: &#39;Jamie&#39;)

# Create an Array of new objects
User.create([{ first_name: &#39;Jamie&#39; }, { first_name: &#39;Jeremy&#39; }])

# Create a single object and pass it into a block to set other attributes.
User.create(first_name: &#39;Jamie&#39;) do |u|
  u.is_admin = false
end

# Creating an Array of new objects using a block, where the block is executed for each object:
User.create([{ first_name: &#39;Jamie&#39; }, { first_name: &#39;Jeremy&#39; }]) do |u|
  u.is_admin = false
end
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 33
      def create(attributes = nil, &amp;block)
        if attributes.is_a?(Array)
          attributes.collect { |attr| create(attr, &amp;block) }
        else
          object = new(attributes, &amp;block)
          object.save
          object
        end
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L33" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-create-21">
            
              create!(attributes = nil, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Creates an object (or multiple objects) and saves it to the database, if validations pass. Raises a <a href="../RecordInvalid.html"><code>RecordInvalid</code></a> error if validations fail, unlike Base#create.</p>

<p>The <code>attributes</code> parameter can be either a <a href="../../Hash.html"><code>Hash</code></a> or an <a href="../../Array.html"><code>Array</code></a> of Hashes. These describe which attributes to be created on the object, or multiple objects when given an <a href="../../Array.html"><code>Array</code></a> of Hashes.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 50
      def create!(attributes = nil, &amp;block)
        if attributes.is_a?(Array)
          attributes.collect { |attr| create!(attr, &amp;block) }
        else
          object = new(attributes, &amp;block)
          object.save!
          object
        end
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L50" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-delete">
            
              delete(id_or_array)
            
          </h3>

          
            <div class="description">
              <p>Deletes the row with a primary key matching the <code>id</code> argument, using an SQL <code>DELETE</code> statement, and returns the number of rows deleted. Active Record objects are not instantiated, so the object’s callbacks are not executed, including any <code>:dependent</code> association options.</p>

<p>You can delete multiple rows at once by passing an <a href="../../Array.html"><code>Array</code></a> of <code>id</code>s.</p>

<p>Note: Although it is often much faster than the alternative, <a href="ClassMethods.html#method-i-destroy"><code>destroy</code></a>, skipping callbacks might bypass business logic in your application that ensures referential integrity or performs other essential jobs.</p>

<h4 id="method-i-delete-label-Examples">Examples</h4>

<pre><code># Delete a single row
Todo.delete(1)

# Delete multiple rows
Todo.delete([2,3,4])
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 565
      def delete(id_or_array)
        delete_by(primary_key =&gt; id_or_array)
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L565" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-destroy">
            
              destroy(id)
            
          </h3>

          
            <div class="description">
              <p>Destroy an object (or multiple objects) that has the given id. The object is instantiated first, therefore all callbacks and filters are fired off before the object is deleted. This method is less efficient than <a href="ClassMethods.html#method-i-delete"><code>delete</code></a> but allows cleanup methods and other actions to be run.</p>

<p>This essentially finds the object (or multiple objects) with the given id, creates a new object from the attributes, and then calls destroy on it.</p>

<h4 id="method-i-destroy-label-Parameters">Parameters</h4>
<ul><li>
<p><code>id</code> - This should be the id or an array of ids to be destroyed.</p>
</li></ul>

<h4 id="method-i-destroy-label-Examples">Examples</h4>

<pre><code># Destroy a single object
Todo.destroy(1)

# Destroy multiple objects
todos = [1,2,3]
Todo.destroy(todos)
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 533
      def destroy(id)
        multiple_ids = if composite_primary_key?
          id.first.is_a?(Array)
        else
          id.is_a?(Array)
        end

        if multiple_ids
          find(id).each(&amp;:destroy)
        else
          find(id).destroy
        end
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L533" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-insert">
            
              insert(attributes, returning: nil, unique_by: nil, record_timestamps: nil)
            
          </h3>

          
            <div class="description">
              <p>Inserts a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>See <a href="ClassMethods.html#method-i-insert_all"><code>insert_all</code></a> for documentation.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 96
      def insert(attributes, returning: nil, unique_by: nil, record_timestamps: nil)
        insert_all([ attributes ], returning: returning, unique_by: unique_by, record_timestamps: record_timestamps)
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L96" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-insert-21">
            
              insert!(attributes, returning: nil, record_timestamps: nil)
            
          </h3>

          
            <div class="description">
              <p>Inserts a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>See <a href="ClassMethods.html#method-i-insert_all-21"><code>insert_all!</code></a> for more.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 185
      def insert!(attributes, returning: nil, record_timestamps: nil)
        insert_all!([ attributes ], returning: returning, record_timestamps: record_timestamps)
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L185" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-insert_all">
            
              insert_all(attributes, returning: nil, unique_by: nil, record_timestamps: nil)
            
          </h3>

          
            <div class="description">
              <p>Inserts multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>The <code>attributes</code> parameter is an <a href="../../Array.html"><code>Array</code></a> of Hashes. Every <a href="../../Hash.html"><code>Hash</code></a> determines the attributes for a single row and must have the same keys.</p>

<p>Rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped. Override with <code>:unique_by</code> (see below).</p>

<p>Returns an <a href="../Result.html"><code>ActiveRecord::Result</code></a> with its contents based on <code>:returning</code> (see below).</p>

<h4 id="method-i-insert_all-label-Options">Options</h4>
<dl class="rdoc-list label-list"><dt>:returning
<dd>
<p>(PostgreSQL only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Pass <code>returning: %w[ id name ]</code> for both id and name or <code>returning: false</code> to omit the underlying <code>RETURNING</code> SQL clause entirely.</p>

<p>You can also pass an SQL string if you need more control on the return values (for example, <code>returning: Arel.sql(&quot;id, name as new_name&quot;)</code>).</p>
</dd><dt>:unique_by
<dd>
<p>(PostgreSQL and SQLite only) By default rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped.</p>

<p>To skip rows according to just one unique index pass <code>:unique_by</code>.</p>

<p>Consider a Book model where no duplicate ISBNs make sense, but if any row has an existing id, or is not unique by another unique index, <a href="../RecordNotUnique.html"><code>ActiveRecord::RecordNotUnique</code></a> is raised.</p>

<p>Unique indexes can be identified by columns or name:</p>

<pre><code>unique_by: :isbn
unique_by: %i[ author_id name ]
unique_by: :index_books_on_isbn
</code></pre>
</dd><dt>:record_timestamps
<dd>
<p>By default, automatic setting of timestamp columns is controlled by the model’s <code>record_timestamps</code> config, matching typical behavior.</p>

<p>To override this and force automatic setting of timestamp columns one way or the other, pass <code>:record_timestamps</code>:</p>

<pre><code>record_timestamps: true  # Always set timestamps automatically
record_timestamps: false # Never set timestamps automatically
</code></pre>
</dd></dl>

<p>Because it relies on the index information from the database <code>:unique_by</code> is recommended to be paired with Active Record’s schema_cache.</p>

<h4 id="method-i-insert_all-label-Example">Example</h4>

<pre><code># Insert records and skip inserting any duplicates.
# Here &quot;Eloquent Ruby&quot; is skipped because its id is not unique.

Book.insert_all([
  { id: 1, title: &quot;Rework&quot;, author: &quot;David&quot; },
  { id: 1, title: &quot;Eloquent Ruby&quot;, author: &quot;Russ&quot; }
])

# insert_all works on chained scopes, and you can use create_with
# to set default attributes for all inserted records.

author.books.create_with(created_at: Time.now).insert_all([
  { id: 1, title: &quot;Rework&quot; },
  { id: 2, title: &quot;Eloquent Ruby&quot; }
])
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 175
      def insert_all(attributes, returning: nil, unique_by: nil, record_timestamps: nil)
        InsertAll.new(self, attributes, on_duplicate: :skip, returning: returning, unique_by: unique_by, record_timestamps: record_timestamps).execute
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L175" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-insert_all-21">
            
              insert_all!(attributes, returning: nil, record_timestamps: nil)
            
          </h3>

          
            <div class="description">
              <p>Inserts multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>The <code>attributes</code> parameter is an <a href="../../Array.html"><code>Array</code></a> of Hashes. Every <a href="../../Hash.html"><code>Hash</code></a> determines the attributes for a single row and must have the same keys.</p>

<p>Raises <a href="../RecordNotUnique.html"><code>ActiveRecord::RecordNotUnique</code></a> if any rows violate a unique index on the table. In that case, no rows are inserted.</p>

<p>To skip duplicate rows, see <a href="ClassMethods.html#method-i-insert_all"><code>insert_all</code></a>. To replace them, see <a href="ClassMethods.html#method-i-upsert_all"><code>upsert_all</code></a>.</p>

<p>Returns an <a href="../Result.html"><code>ActiveRecord::Result</code></a> with its contents based on <code>:returning</code> (see below).</p>

<h4 id="method-i-insert_all-21-label-Options">Options</h4>
<dl class="rdoc-list label-list"><dt>:returning
<dd>
<p>(PostgreSQL only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Pass <code>returning: %w[ id name ]</code> for both id and name or <code>returning: false</code> to omit the underlying <code>RETURNING</code> SQL clause entirely.</p>

<p>You can also pass an SQL string if you need more control on the return values (for example, <code>returning: Arel.sql(&quot;id, name as new_name&quot;)</code>).</p>
</dd><dt>:record_timestamps
<dd>
<p>By default, automatic setting of timestamp columns is controlled by the model’s <code>record_timestamps</code> config, matching typical behavior.</p>

<p>To override this and force automatic setting of timestamp columns one way or the other, pass <code>:record_timestamps</code>:</p>

<pre><code>record_timestamps: true  # Always set timestamps automatically
record_timestamps: false # Never set timestamps automatically
</code></pre>
</dd></dl>

<h4 id="method-i-insert_all-21-label-Examples">Examples</h4>

<pre><code># Insert multiple records
Book.insert_all!([
  { title: &quot;Rework&quot;, author: &quot;David&quot; },
  { title: &quot;Eloquent Ruby&quot;, author: &quot;Russ&quot; }
])

# Raises ActiveRecord::RecordNotUnique because &quot;Eloquent Ruby&quot;
# does not have a unique id.
Book.insert_all!([
  { id: 1, title: &quot;Rework&quot;, author: &quot;David&quot; },
  { id: 1, title: &quot;Eloquent Ruby&quot;, author: &quot;Russ&quot; }
])
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 242
      def insert_all!(attributes, returning: nil, record_timestamps: nil)
        InsertAll.new(self, attributes, on_duplicate: :raise, returning: returning, record_timestamps: record_timestamps).execute
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L242" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-instantiate">
            
              instantiate(attributes, column_types = {}, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Given an attributes hash, <code>instantiate</code> returns a new instance of the appropriate class. Accepts only keys as strings.</p>

<p>For example, <code>Post.all</code> may return Comments, Messages, and Emails by storing the record’s subclass in a <code>type</code> attribute. By calling <code>instantiate</code> instead of <code>new</code>, finder methods ensure they get new instances of the appropriate class for each record.</p>

<p>See <code>ActiveRecord::Inheritance#discriminate_class_for_record</code> to see how this “single-table” inheritance mapping is implemented.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 376
      def instantiate(attributes, column_types = {}, &amp;block)
        klass = discriminate_class_for_record(attributes)
        instantiate_instance_of(klass, attributes, column_types, &amp;block)
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L376" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-query_constraints">
            
              query_constraints(*columns_list)
            
          </h3>

          
            <div class="description">
              <p>Accepts a list of attribute names to be used in the WHERE clause of SELECT / UPDATE / DELETE queries and in the ORDER BY clause for ‘#first` and `#last` finder methods.</p>

<pre><code>class Developer &lt; ActiveRecord::Base
  query_constraints :company_id, :id
end

developer = Developer.first
# SELECT &quot;developers&quot;.* FROM &quot;developers&quot; ORDER BY &quot;developers&quot;.&quot;company_id&quot; ASC, &quot;developers&quot;.&quot;id&quot; ASC LIMIT 1
developer.inspect # =&gt; #&lt;Developer id: 1, company_id: 1, ...&gt;

developer.update!(name: &quot;Nikita&quot;)
# UPDATE &quot;developers&quot; SET &quot;name&quot; = &#39;Nikita&#39; WHERE &quot;developers&quot;.&quot;company_id&quot; = 1 AND &quot;developers&quot;.&quot;id&quot; = 1

It is possible to update attribute used in the query_by clause:
developer.update!(company_id: 2)
# UPDATE &quot;developers&quot; SET &quot;company_id&quot; = 2 WHERE &quot;developers&quot;.&quot;company_id&quot; = 1 AND &quot;developers&quot;.&quot;id&quot; = 1

developer.name = &quot;Bob&quot;
developer.save!
# UPDATE &quot;developers&quot; SET &quot;name&quot; = &#39;Bob&#39; WHERE &quot;developers&quot;.&quot;company_id&quot; = 1 AND &quot;developers&quot;.&quot;id&quot; = 1

developer.destroy!
# DELETE FROM &quot;developers&quot; WHERE &quot;developers&quot;.&quot;company_id&quot; = 1 AND &quot;developers&quot;.&quot;id&quot; = 1

developer.delete
# DELETE FROM &quot;developers&quot; WHERE &quot;developers&quot;.&quot;company_id&quot; = 1 AND &quot;developers&quot;.&quot;id&quot; = 1

developer.reload
# SELECT &quot;developers&quot;.* FROM &quot;developers&quot; WHERE &quot;developers&quot;.&quot;company_id&quot; = 1 AND &quot;developers&quot;.&quot;id&quot; = 1 LIMIT 1
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 488
      def query_constraints(*columns_list)
        raise ArgumentError, &quot;You must specify at least one column to be used in querying&quot; if columns_list.empty?

        @query_constraints_list = columns_list.map(&amp;:to_s)
        @has_query_constraints = @query_constraints_list
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L488" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-update">
            
              update(id = :all, attributes)
            
          </h3>

          
            <div class="description">
              <p>Updates an object (or multiple objects) and saves it to the database, if validations pass. The resulting object is returned whether the object was saved successfully to the database or not.</p>

<h4 id="method-i-update-label-Parameters">Parameters</h4>
<ul><li>
<p><code>id</code> - This should be the id or an array of ids to be updated. Optional argument, defaults to all records in the relation.</p>
</li><li>
<p><code>attributes</code> - This should be a hash of attributes or an array of hashes.</p>
</li></ul>

<h4 id="method-i-update-label-Examples">Examples</h4>

<pre><code># Updates one record
Person.update(15, user_name: &quot;Samuel&quot;, group: &quot;expert&quot;)

# Updates multiple records
people = { 1 =&gt; { &quot;first_name&quot; =&gt; &quot;David&quot; }, 2 =&gt; { &quot;first_name&quot; =&gt; &quot;Jeremy&quot; } }
Person.update(people.keys, people.values)

# Updates multiple records from the result of a relation
people = Person.where(group: &quot;expert&quot;)
people.update(group: &quot;masters&quot;)
</code></pre>

<p>Note: Updating a large number of records will run an UPDATE query for each record, which may cause a performance issue. When running callbacks is not needed for each record update, it is preferred to use <a href="../Relation.html#method-i-update_all">update_all</a> for updating all records in a single query.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 408
      def update(id = :all, attributes)
        if id.is_a?(Array)
          if id.any?(ActiveRecord::Base)
            raise ArgumentError,
              &quot;You are passing an array of ActiveRecord::Base instances to `update`. &quot; \
              &quot;Please pass the ids of the objects by calling `pluck(:id)` or `map(&amp;:id)`.&quot;
          end
          id.map { |one_id| find(one_id) }.each_with_index { |object, idx|
            object.update(attributes[idx])
          }
        elsif id == :all
          all.each { |record| record.update(attributes) }
        else
          if ActiveRecord::Base === id
            raise ArgumentError,
              &quot;You are passing an instance of ActiveRecord::Base to `update`. &quot; \
              &quot;Please pass the id of the object by calling `.id`.&quot;
          end
          object = find(id)
          object.update(attributes)
          object
        end
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L408" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-update-21">
            
              update!(id = :all, attributes)
            
          </h3>

          
            <div class="description">
              <p>Updates the object (or multiple objects) just like <a href="ClassMethods.html#method-i-update"><code>update</code></a> but calls <a href="ClassMethods.html#method-i-update-21"><code>update!</code></a> instead of <code>update</code>, so an exception is raised if the record is invalid and saving will fail.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 434
      def update!(id = :all, attributes)
        if id.is_a?(Array)
          if id.any?(ActiveRecord::Base)
            raise ArgumentError,
              &quot;You are passing an array of ActiveRecord::Base instances to `update!`. &quot; \
              &quot;Please pass the ids of the objects by calling `pluck(:id)` or `map(&amp;:id)`.&quot;
          end
          id.map { |one_id| find(one_id) }.each_with_index { |object, idx|
            object.update!(attributes[idx])
          }
        elsif id == :all
          all.each { |record| record.update!(attributes) }
        else
          if ActiveRecord::Base === id
            raise ArgumentError,
              &quot;You are passing an instance of ActiveRecord::Base to `update!`. &quot; \
              &quot;Please pass the id of the object by calling `.id`.&quot;
          end
          object = find(id)
          object.update!(attributes)
          object
        end
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L434" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-upsert">
            
              upsert(attributes, **kwargs)
            
          </h3>

          
            <div class="description">
              <p>Updates or inserts (upserts) a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>See <a href="ClassMethods.html#method-i-upsert_all"><code>upsert_all</code></a> for documentation.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 252
      def upsert(attributes, **kwargs)
        upsert_all([ attributes ], **kwargs)
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L252" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-upsert_all">
            
              upsert_all(attributes, on_duplicate: :update, update_only: nil, returning: nil, unique_by: nil, record_timestamps: nil)
            
          </h3>

          
            <div class="description">
              <p>Updates or inserts (upserts) multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>The <code>attributes</code> parameter is an <a href="../../Array.html"><code>Array</code></a> of Hashes. Every <a href="../../Hash.html"><code>Hash</code></a> determines the attributes for a single row and must have the same keys.</p>

<p>Returns an <a href="../Result.html"><code>ActiveRecord::Result</code></a> with its contents based on <code>:returning</code> (see below).</p>

<p>By default, <code>upsert_all</code> will update all the columns that can be updated when there is a conflict. These are all the columns except primary keys, read-only columns, and columns covered by the optional <code>unique_by</code>.</p>

<h4 id="method-i-upsert_all-label-Options">Options</h4>
<dl class="rdoc-list label-list"><dt>:returning
<dd>
<p>(PostgreSQL only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Pass <code>returning: %w[ id name ]</code> for both id and name or <code>returning: false</code> to omit the underlying <code>RETURNING</code> SQL clause entirely.</p>

<p>You can also pass an SQL string if you need more control on the return values (for example, <code>returning: Arel.sql(&quot;id, name as new_name&quot;)</code>).</p>
</dd><dt>:unique_by
<dd>
<p>(PostgreSQL and SQLite only) By default rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped.</p>

<p>To skip rows according to just one unique index pass <code>:unique_by</code>.</p>

<p>Consider a Book model where no duplicate ISBNs make sense, but if any row has an existing id, or is not unique by another unique index, <a href="../RecordNotUnique.html"><code>ActiveRecord::RecordNotUnique</code></a> is raised.</p>

<p>Unique indexes can be identified by columns or name:</p>

<pre><code>unique_by: :isbn
unique_by: %i[ author_id name ]
unique_by: :index_books_on_isbn
</code></pre>
</dd></dl>

<p>Because it relies on the index information from the database <code>:unique_by</code> is recommended to be paired with Active Record’s schema_cache.</p>
<dl class="rdoc-list label-list"><dt>:on_duplicate
<dd>
<p>Configure the SQL update sentence that will be used in case of conflict.</p>

<p>NOTE: If you use this option you must provide all the columns you want to update by yourself.</p>

<p>Example:</p>

<pre><code>Commodity.upsert_all(
  [
    { id: 2, name: &quot;Copper&quot;, price: 4.84 },
    { id: 4, name: &quot;Gold&quot;, price: 1380.87 },
    { id: 6, name: &quot;Aluminium&quot;, price: 0.35 }
  ],
  on_duplicate: Arel.sql(&quot;price = GREATEST(commodities.price, EXCLUDED.price)&quot;)
)
</code></pre>

<p>See the related <code>:update_only</code> option. Both options can’t be used at the same time.</p>
</dd><dt>:update_only
<dd>
<p>Provide a list of column names that will be updated in case of conflict. If not provided, <code>upsert_all</code> will update all the columns that can be updated. These are all the columns except primary keys, read-only columns, and columns covered by the optional <code>unique_by</code></p>

<p>Example:</p>

<pre><code>Commodity.upsert_all(
  [
    { id: 2, name: &quot;Copper&quot;, price: 4.84 },
    { id: 4, name: &quot;Gold&quot;, price: 1380.87 },
    { id: 6, name: &quot;Aluminium&quot;, price: 0.35 }
  ],
  update_only: [:price] # Only prices will be updated
)
</code></pre>

<p>See the related <code>:on_duplicate</code> option. Both options can’t be used at the same time.</p>
</dd><dt>:record_timestamps
<dd>
<p>By default, automatic setting of timestamp columns is controlled by the model’s <code>record_timestamps</code> config, matching typical behavior.</p>

<p>To override this and force automatic setting of timestamp columns one way or the other, pass <code>:record_timestamps</code>:</p>

<pre><code>record_timestamps: true  # Always set timestamps automatically
record_timestamps: false # Never set timestamps automatically
</code></pre>
</dd></dl>

<h4 id="method-i-upsert_all-label-Examples">Examples</h4>

<pre><code># Inserts multiple records, performing an upsert when records have duplicate ISBNs.
# Here &quot;Eloquent Ruby&quot; overwrites &quot;Rework&quot; because its ISBN is duplicate.

Book.upsert_all([
  { title: &quot;Rework&quot;, author: &quot;David&quot;, isbn: &quot;1&quot; },
  { title: &quot;Eloquent Ruby&quot;, author: &quot;Russ&quot;, isbn: &quot;1&quot; }
], unique_by: :isbn)

Book.find_by(isbn: &quot;1&quot;).title # =&gt; &quot;Eloquent Ruby&quot;
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/persistence.rb, line 362
      def upsert_all(attributes, on_duplicate: :update, update_only: nil, returning: nil, unique_by: nil, record_timestamps: nil)
        InsertAll.new(self, attributes, on_duplicate: on_duplicate, update_only: update_only, returning: returning, unique_by: unique_by, record_timestamps: record_timestamps).execute
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/d39db5d1891f7509cde2efc425c9d69bbb77e670/activerecord/lib/active_record/persistence.rb#L362" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
      
    
  
</div>

    </div>
</div>
