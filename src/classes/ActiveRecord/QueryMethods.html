---
title: ActiveRecord::QueryMethods
layout: default
---
<div class="main">
    <div class="banner">
        
            <span>Ruby on Rails 8.1.0</span><br />
        
        <div class="type">Module</div>
        <h1>
            ActiveRecord::QueryMethods
            
        </h1>
        <ul class="files">
            
            <li><a href="../../files/activerecord/lib/active_record/relation/query_methods_rb.html">activerecord/lib/active_record/relation/query_methods.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
  

  

  
  


  
    <h2 id="namespace">Namespace</h2>

    

    
      <h3 id="class">Class</h3>
      <ul>
      
        <li><a href="QueryMethods/WhereChain.html">ActiveRecord::QueryMethods::WhereChain</a></li>
      
      </ul>
    
  

  
    <h2 id="methods">Methods</h2>
    <ul>
      
        <li>
          <a href="#method-i-and">and</a>
        </li>
      
        <li>
          <a href="#method-i-annotate">annotate</a>
        </li>
      
        <li>
          <a href="#method-i-create_with">create_with</a>
        </li>
      
        <li>
          <a href="#method-i-distinct">distinct</a>
        </li>
      
        <li>
          <a href="#method-i-eager_load">eager_load</a>
        </li>
      
        <li>
          <a href="#method-i-excluding">excluding</a>
        </li>
      
        <li>
          <a href="#method-i-extending">extending</a>
        </li>
      
        <li>
          <a href="#method-i-extract_associated">extract_associated</a>
        </li>
      
        <li>
          <a href="#method-i-from">from</a>
        </li>
      
        <li>
          <a href="#method-i-group">group</a>
        </li>
      
        <li>
          <a href="#method-i-having">having</a>
        </li>
      
        <li>
          <a href="#method-i-in_order_of">in_order_of</a>
        </li>
      
        <li>
          <a href="#method-i-includes">includes</a>
        </li>
      
        <li>
          <a href="#method-i-invert_where">invert_where</a>
        </li>
      
        <li>
          <a href="#method-i-joins">joins</a>
        </li>
      
        <li>
          <a href="#method-i-left_joins">left_joins</a>
        </li>
      
        <li>
          <a href="#method-i-left_outer_joins">left_outer_joins</a>
        </li>
      
        <li>
          <a href="#method-i-limit">limit</a>
        </li>
      
        <li>
          <a href="#method-i-lock">lock</a>
        </li>
      
        <li>
          <a href="#method-i-none">none</a>
        </li>
      
        <li>
          <a href="#method-i-offset">offset</a>
        </li>
      
        <li>
          <a href="#method-i-optimizer_hints">optimizer_hints</a>
        </li>
      
        <li>
          <a href="#method-i-or">or</a>
        </li>
      
        <li>
          <a href="#method-i-order">order</a>
        </li>
      
        <li>
          <a href="#method-i-preload">preload</a>
        </li>
      
        <li>
          <a href="#method-i-readonly">readonly</a>
        </li>
      
        <li>
          <a href="#method-i-references">references</a>
        </li>
      
        <li>
          <a href="#method-i-regroup">regroup</a>
        </li>
      
        <li>
          <a href="#method-i-reorder">reorder</a>
        </li>
      
        <li>
          <a href="#method-i-reselect">reselect</a>
        </li>
      
        <li>
          <a href="#method-i-reverse_order">reverse_order</a>
        </li>
      
        <li>
          <a href="#method-i-rewhere">rewhere</a>
        </li>
      
        <li>
          <a href="#method-i-select">select</a>
        </li>
      
        <li>
          <a href="#method-i-strict_loading">strict_loading</a>
        </li>
      
        <li>
          <a href="#method-i-structurally_compatible-3F">structurally_compatible?</a>
        </li>
      
        <li>
          <a href="#method-i-uniq-21">uniq!</a>
        </li>
      
        <li>
          <a href="#method-i-unscope">unscope</a>
        </li>
      
        <li>
          <a href="#method-i-where">where</a>
        </li>
      
        <li>
          <a href="#method-i-with">with</a>
        </li>
      
        <li>
          <a href="#method-i-with_recursive">with_recursive</a>
        </li>
      
        <li>
          <a href="#method-i-without">without</a>
        </li>
      
    </ul>
  

  

  
    

    

    
      <!-- Section constants -->
      <h2 id="constants">Constants</h2>
      <table border='0' cellpadding='5'>
        
          <tr valign='top'>
            <td class="attr-name">FROZEN_EMPTY_ARRAY</td>
            <td>=</td>
            <td class="attr-value">[].freeze</td>
          </tr>
          
        
          <tr valign='top'>
            <td class="attr-name">FROZEN_EMPTY_HASH</td>
            <td>=</td>
            <td class="attr-value">{}.freeze</td>
          </tr>
          
        
          <tr valign='top'>
            <td class="attr-name">VALID_UNSCOPING_VALUES</td>
            <td>=</td>
            <td class="attr-value">Set.new([:where, :select, :group, :order, :lock,
:limit, :offset, :joins, :left_outer_joins, :annotate,
:includes, :eager_load, :preload, :from, :readonly,
:having, :optimizer_hints, :with])</td>
          </tr>
          
        
      </table>
    

    

    <!-- Methods -->
    
    
      <h2 id="instance-public-methods">Instance Public methods</h2>
      
        <div class="method">
          <h3 id="method-i-and"><code><b>and</b>(other)</code></h3>

          <div class="description">
<p>Returns a new relation, which is the logical intersection of this relation and the one passed as an argument.</p>

<p>The two relations must be structurally compatible: they must be scoping the same model, and they must differ only by <a href="QueryMethods.html#method-i-where"><code>where</code></a> (if no <a href="QueryMethods.html#method-i-group"><code>group</code></a> has been defined) or <a href="QueryMethods.html#method-i-having"><code>having</code></a> (if a <a href="QueryMethods.html#method-i-group"><code>group</code></a> is present).</p>

<pre><code>Post.where(id: [1, 2]).and(Post.where(id: [2, 3]))
# SELECT `posts`.* FROM `posts` WHERE `posts`.`id` IN (1, 2) AND `posts`.`id` IN (2, 3)
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1135
def and(other)
  if other.is_a?(Relation)
    spawn.and!(other)
  else
    raise ArgumentError, &quot;You have passed #{other.class.name} object to #and. Pass an ActiveRecord::Relation object instead.&quot;
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1135" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-annotate"><code><b>annotate</b>(*args)</code></h3>

          <div class="description">
<p>Adds an SQL comment to queries generated from this relation. For example:</p>

<pre><code>User.annotate(&quot;selecting user names&quot;).select(:name)
# SELECT &quot;users&quot;.&quot;name&quot; FROM &quot;users&quot; /* selecting user names */

User.annotate(&quot;selecting&quot;, &quot;user&quot;, &quot;names&quot;).select(:name)
# SELECT &quot;users&quot;.&quot;name&quot; FROM &quot;users&quot; /* selecting */ /* user */ /* names */
</code></pre>

<p>The SQL block comment delimiters, ‚Äú/*‚Äù and ‚Äú*/‚Äù, will be added automatically.</p>

<p>Some escaping is performed, however untrusted user input should not be used.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1530
def annotate(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.annotate!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1530" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-create_with"><code><b>create_with</b>(value)</code></h3>

          <div class="description">
<p>Sets attributes to be used when creating new records from a relation object.</p>

<pre><code>users = User.where(name: &#39;Oscar&#39;)
users.new.name # =&gt; &#39;Oscar&#39;

users = users.create_with(name: &#39;DHH&#39;)
users.new.name # =&gt; &#39;DHH&#39;
</code></pre>

<p>You can pass <code>nil</code> to <a href="QueryMethods.html#method-i-create_with"><code>create_with</code></a> to reset attributes:</p>

<pre><code>users = users.create_with(nil)
users.new.name # =&gt; &#39;Oscar&#39;
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1347
def create_with(value)
  spawn.create_with!(value)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1347" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-distinct"><code><b>distinct</b>(value = true)</code></h3>

          <div class="description">
<p>Specifies whether the records should be unique or not. For example:</p>

<pre><code>User.select(:name)
# Might return two records with the same name

User.select(:name).distinct
# Returns 1 record per distinct name

User.select(:name).distinct.distinct(false)
# You can also remove the uniqueness
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1411
def distinct(value = true)
  spawn.distinct!(value)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1411" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-eager_load"><code><b>eager_load</b>(*args)</code></h3>

          <div class="description">
<p>Specify associations <code>args</code> to be eager loaded using a <code>LEFT OUTER JOIN</code>. Performs a single query joining all specified associations. For example:</p>

<pre><code>users = User.eager_load(:address).limit(5)
users.each do |user|
  user.address.city
end

# SELECT &quot;users&quot;.&quot;id&quot; AS t0_r0, &quot;users&quot;.&quot;name&quot; AS t0_r1, ... FROM &quot;users&quot;
#   LEFT OUTER JOIN &quot;addresses&quot; ON &quot;addresses&quot;.&quot;id&quot; = &quot;users&quot;.&quot;address_id&quot;
#   LIMIT 5
</code></pre>

<p>Instead of loading the 5 addresses with 5 separate queries, all addresses are loaded with a single joined query.</p>

<p>Loading multiple and nested associations is possible using Hashes and Arrays, similar to <a href="QueryMethods.html#method-i-includes"><code>includes</code></a>:</p>

<pre><code>User.eager_load(:address, friends: [:address, :followers])
# SELECT &quot;users&quot;.&quot;id&quot; AS t0_r0, &quot;users&quot;.&quot;name&quot; AS t0_r1, ... FROM &quot;users&quot;
#   LEFT OUTER JOIN &quot;addresses&quot; ON &quot;addresses&quot;.&quot;id&quot; = &quot;users&quot;.&quot;address_id&quot;
#   LEFT OUTER JOIN &quot;friends&quot; ON &quot;friends&quot;.&quot;user_id&quot; = &quot;users&quot;.&quot;id&quot;
#   ...
</code></pre>

<p>NOTE: Loading the associations in a join can result in many rows that contain redundant data and it performs poorly at scale.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 290
def eager_load(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.eager_load!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L290" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-excluding"><code><b>excluding</b>(*records)</code></h3>

          <div class="description">
<p>Excludes the specified record (or collection of records) from the resulting relation. For example:</p>

<pre><code>Post.excluding(post)
# SELECT &quot;posts&quot;.* FROM &quot;posts&quot; WHERE &quot;posts&quot;.&quot;id&quot; != 1

Post.excluding(post_one, post_two)
# SELECT &quot;posts&quot;.* FROM &quot;posts&quot; WHERE &quot;posts&quot;.&quot;id&quot; NOT IN (1, 2)

Post.excluding(Post.drafts)
# SELECT &quot;posts&quot;.* FROM &quot;posts&quot; WHERE &quot;posts&quot;.&quot;id&quot; NOT IN (3, 4, 5)
</code></pre>

<p>This can also be called on associations. As with the above example, either a single record of collection thereof may be specified:</p>

<pre><code>post = Post.find(1)
comment = Comment.find(2)
post.comments.excluding(comment)
# SELECT &quot;comments&quot;.* FROM &quot;comments&quot; WHERE &quot;comments&quot;.&quot;post_id&quot; = 1 AND &quot;comments&quot;.&quot;id&quot; != 2
</code></pre>

<p>This is short-hand for <a href="QueryMethods.html#method-i-where"><code>.where.not(id: post.id)</code></a> and <a href="QueryMethods.html#method-i-where"><code>.where.not(id: [post_one.id, post_two.id])</code></a>.</p>

<p>An <code>ArgumentError</code> will be raised if either no records are specified, or if any of the records in the collection (if a collection is passed in) are not instances of the same model that the relation is scoping.</p>
</div>

          
            <p class="method__aka">
              Also aliased as:
              
              <a href="/classes/ActiveRecord/QueryMethods.html#method-i-without" class="ref-link"><code>without</code></a>.
            </p>
          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1575
def excluding(*records)
  relations = records.extract! { |element| element.is_a?(Relation) }
  records.flatten!(1)
  records.compact!

  unless records.all?(model) &amp;&amp; relations.all? { |relation| relation.model == model }
    raise ArgumentError, &quot;You must only pass a single or collection of #{model.name} objects to ##{__callee__}.&quot;
  end

  spawn.excluding!(records + relations.flat_map(&amp;:ids))
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1575" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-extending"><code><b>extending</b>(*modules, &amp;block)</code></h3>

          <div class="description">
<p>Used to extend a scope with additional methods, either through a module or through a block provided.</p>

<p>The object returned is a relation, which can be further extended.</p>

<h3 id="method-i-extending-label-Using+a+Module">Using a Module</h3>

<pre><code>module Pagination
  def page(number)
    # pagination code goes here
  end
end

scope = Model.all.extending(Pagination)
scope.page(params[:page])
</code></pre>

<p>You can also pass a list of modules:</p>

<pre><code>scope = Model.all.extending(Pagination, SomethingElse)
</code></pre>

<h3 id="method-i-extending-label-Using+a+Block">Using a Block</h3>

<pre><code>scope = Model.all.extending do
  def page(number)
    # pagination code goes here
  end
end
scope.page(params[:page])
</code></pre>

<p>You can also use a block and a module list:</p>

<pre><code>scope = Model.all.extending(Pagination) do
  def per_page(number)
    # pagination code goes here
  end
end
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1457
def extending(*modules, &amp;block)
  if modules.any? || block
    spawn.extending!(*modules, &amp;block)
  else
    self
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1457" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-extract_associated"><code><b>extract_associated</b>(association)</code></h3>

          <div class="description">
<p>Extracts a named <code>association</code> from the relation. The named association is first preloaded, then the individual association records are collected from the relation. Like so:</p>

<pre><code>account.memberships.extract_associated(:user)
# =&gt; Returns collection of User records
</code></pre>

<p>This is short-hand for:</p>

<pre><code>account.memberships.preload(:user).collect(&amp;:user)
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 341
def extract_associated(association)
  preload(association).collect(&amp;association)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L341" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-from"><code><b>from</b>(value, subquery_name = nil)</code></h3>

          <div class="description">
<p>Specifies the table from which the records will be fetched. For example:</p>

<pre><code>Topic.select(&#39;title&#39;).from(&#39;posts&#39;)
# SELECT title FROM posts
</code></pre>

<p>Can accept other relation objects. For example:</p>

<pre><code>Topic.select(&#39;title&#39;).from(Topic.approved)
# SELECT title FROM (SELECT * FROM topics WHERE approved = &#39;t&#39;) subquery
</code></pre>

<p>Passing a second argument (string or symbol), creates the alias for the SQL from clause. Otherwise the alias ‚Äúsubquery‚Äù is used:</p>

<pre><code>Topic.select(&#39;a.title&#39;).from(Topic.approved, :a)
# SELECT a.title FROM (SELECT * FROM topics WHERE approved = &#39;t&#39;) a
</code></pre>

<p>It does not add multiple arguments to the SQL from clause. The last <code>from</code> chained is the one used:</p>

<pre><code>Topic.select(&#39;title&#39;).from(Topic.approved).from(Topic.inactive)
# SELECT title FROM (SELECT topics.* FROM topics WHERE topics.active = &#39;f&#39;) subquery
</code></pre>

<p>For multiple arguments for the SQL from clause, you can pass a string with the exact elements in the SQL from list:</p>

<pre><code>color = &quot;red&quot;
Color
  .from(&quot;colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue)&quot;)
  .where(&quot;colorvalue-&gt;&gt;&#39;color&#39; = ?&quot;, color)
  .select(&quot;c.*&quot;).to_a
# SELECT c.*
# FROM colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue)
# WHERE (colorvalue-&gt;&gt;&#39;color&#39; = &#39;red&#39;)
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1392
def from(value, subquery_name = nil)
  spawn.from!(value, subquery_name)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1392" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-group"><code><b>group</b>(*args)</code></h3>

          <div class="description">
<p>Allows to specify a group attribute:</p>

<pre><code>User.group(:name)
# SELECT &quot;users&quot;.* FROM &quot;users&quot; GROUP BY name
</code></pre>

<p>Returns an array with distinct records based on the <code>group</code> attribute:</p>

<pre><code>User.select([:id, :name])
# =&gt; [#&lt;User id: 1, name: &quot;Oscar&quot;&gt;, #&lt;User id: 2, name: &quot;Oscar&quot;&gt;, #&lt;User id: 3, name: &quot;Foo&quot;&gt;]

User.group(:name)
# =&gt; [#&lt;User id: 3, name: &quot;Foo&quot;, ...&gt;, #&lt;User id: 2, name: &quot;Oscar&quot;, ...&gt;]

User.group(&#39;name AS grouped_name, age&#39;)
# =&gt; [#&lt;User id: 3, name: &quot;Foo&quot;, age: 21, ...&gt;, #&lt;User id: 2, name: &quot;Oscar&quot;, age: 21, ...&gt;, #&lt;User id: 5, name: &quot;Foo&quot;, age: 23, ...&gt;]
</code></pre>

<p>Passing in an array of attributes to group by is also supported.</p>

<pre><code>User.select([:id, :first_name]).group(:id, :first_name).first(3)
# =&gt; [#&lt;User id: 1, first_name: &quot;Bill&quot;&gt;, #&lt;User id: 2, first_name: &quot;Earl&quot;&gt;, #&lt;User id: 3, first_name: &quot;Beto&quot;&gt;]
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 573
def group(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.group!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L573" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-having"><code><b>having</b>(opts, *rest)</code></h3>

          <div class="description">
<p>Allows to specify a HAVING clause. Note that you can‚Äôt use HAVING without also specifying a GROUP clause.</p>

<pre><code>Order.having(&#39;SUM(price) &gt; 30&#39;).group(&#39;user_id&#39;)
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1197
def having(opts, *rest)
  opts.blank? ? self : spawn.having!(opts, *rest)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1197" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-in_order_of"><code><b>in_order_of</b>(column, values, filter: true)</code></h3>

          <div class="description">
<p>Applies an <code>ORDER BY</code> clause based on a given <code>column</code>, ordered and filtered by a specific set of <code>values</code>.</p>

<pre><code>User.in_order_of(:id, [1, 5, 3])
# SELECT &quot;users&quot;.* FROM &quot;users&quot;
#   WHERE &quot;users&quot;.&quot;id&quot; IN (1, 5, 3)
#   ORDER BY CASE
#     WHEN &quot;users&quot;.&quot;id&quot; = 1 THEN 1
#     WHEN &quot;users&quot;.&quot;id&quot; = 5 THEN 2
#     WHEN &quot;users&quot;.&quot;id&quot; = 3 THEN 3
#   END ASC
</code></pre>

<p><code>column</code> can point to an enum column; the actual query generated may be different depending on the database adapter and the column definition.</p>

<pre><code>class Conversation &lt; ActiveRecord::Base
  enum :status, [ :active, :archived ]
end

Conversation.in_order_of(:status, [:archived, :active])
# SELECT &quot;conversations&quot;.* FROM &quot;conversations&quot;
#   WHERE &quot;conversations&quot;.&quot;status&quot; IN (1, 0)
#   ORDER BY CASE
#     WHEN &quot;conversations&quot;.&quot;status&quot; = 1 THEN 1
#     WHEN &quot;conversations&quot;.&quot;status&quot; = 0 THEN 2
#   END ASC
</code></pre>

<p><code>values</code> can also include <code>nil</code>.</p>

<pre><code>Conversation.in_order_of(:status, [nil, :archived, :active])
# SELECT &quot;conversations&quot;.* FROM &quot;conversations&quot;
#   WHERE (&quot;conversations&quot;.&quot;status&quot; IN (1, 0) OR &quot;conversations&quot;.&quot;status&quot; IS NULL)
#   ORDER BY CASE
#     WHEN &quot;conversations&quot;.&quot;status&quot; IS NULL THEN 1
#     WHEN &quot;conversations&quot;.&quot;status&quot; = 1 THEN 2
#     WHEN &quot;conversations&quot;.&quot;status&quot; = 0 THEN 3
#   END ASC
</code></pre>

<p><code>filter</code> can be set to <code>false</code> to include all results instead of only the ones specified in <code>values</code>.</p>

<pre><code>Conversation.in_order_of(:status, [:archived, :active], filter: false)
# SELECT &quot;conversations&quot;.* FROM &quot;conversations&quot;
#   ORDER BY CASE
#     WHEN &quot;conversations&quot;.&quot;status&quot; = 1 THEN 1
#     WHEN &quot;conversations&quot;.&quot;status&quot; = 0 THEN 2
#     ELSE 3
#   END ASC
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 717
def in_order_of(column, values, filter: true)
  model.disallow_raw_sql!([column], permit: model.adapter_class.column_name_with_order_matcher)
  return spawn.none! if values.empty?

  references = column_references([column])
  self.references_values |= references unless references.empty?

  values = values.map { |value| model.type_caster.type_cast_for_database(column, value) }
  arel_column = column.is_a?(Arel::Nodes::SqlLiteral) ? column : order_column(column.to_s)

  scope = spawn.order!(build_case_for_value_position(arel_column, values, filter: filter))

  if filter
    where_clause =
      if values.include?(nil)
        arel_column.in(values.compact).or(arel_column.eq(nil))
      else
        arel_column.in(values)
      end

    scope = scope.where!(where_clause)
  end

  scope
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L717" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-includes"><code><b>includes</b>(*args)</code></h3>

          <div class="description">
<p>Specify associations <code>args</code> to be eager loaded to prevent N + 1 queries. A separate query is performed for each association, unless a join is required by conditions.</p>

<p>For example:</p>

<pre><code>users = User.includes(:address).limit(5)
users.each do |user|
  user.address.city
end

# SELECT &quot;users&quot;.* FROM &quot;users&quot; LIMIT 5
# SELECT &quot;addresses&quot;.* FROM &quot;addresses&quot; WHERE &quot;addresses&quot;.&quot;id&quot; IN (1,2,3,4,5)
</code></pre>

<p>Instead of loading the 5 addresses with 5 separate queries, all addresses are loaded with a single query.</p>

<p>Loading the associations in a separate query will often result in a performance improvement over a simple join, as a join can result in many rows that contain redundant data and it performs poorly at scale.</p>

<p>You can also specify multiple associations. Each association will result in an additional query:</p>

<pre><code>User.includes(:address, :friends).to_a
# SELECT &quot;users&quot;.* FROM &quot;users&quot;
# SELECT &quot;addresses&quot;.* FROM &quot;addresses&quot; WHERE &quot;addresses&quot;.&quot;id&quot; IN (1,2,3,4,5)
# SELECT &quot;friends&quot;.* FROM &quot;friends&quot; WHERE &quot;friends&quot;.&quot;user_id&quot; IN (1,2,3,4,5)
</code></pre>

<p>Loading nested associations is possible using a Hash:</p>

<pre><code>User.includes(:address, friends: [:address, :followers])
</code></pre>

<h3 id="method-i-includes-label-Conditions">Conditions</h3>

<p>If you want to add string conditions to your included models, you‚Äôll have to explicitly reference them. For example:</p>

<pre><code>User.includes(:posts).where(&#39;posts.name = ?&#39;, &#39;example&#39;).to_a
</code></pre>

<p>Will throw an error, but this will work:</p>

<pre><code>User.includes(:posts).where(&#39;posts.name = ?&#39;, &#39;example&#39;).references(:posts).to_a
# SELECT &quot;users&quot;.&quot;id&quot; AS t0_r0, ... FROM &quot;users&quot;
#   LEFT OUTER JOIN &quot;posts&quot; ON &quot;posts&quot;.&quot;user_id&quot; = &quot;users&quot;.&quot;id&quot;
#   WHERE &quot;posts&quot;.&quot;name&quot; = ?  [[&quot;name&quot;, &quot;example&quot;]]
</code></pre>

<p>As the <code>LEFT OUTER JOIN</code> already contains the posts, the second query for the posts is no longer performed.</p>

<p>Note that <a href="QueryMethods.html#method-i-includes"><code>includes</code></a> works with association names while <a href="QueryMethods.html#method-i-references"><code>references</code></a> needs the actual table name.</p>

<p>If you pass the conditions via a <a href="../Hash.html"><code>Hash</code></a>, you don‚Äôt need to call <a href="QueryMethods.html#method-i-references"><code>references</code></a> explicitly, as <a href="QueryMethods.html#method-i-where"><code>where</code></a> references the tables for you. For example, this will work correctly:</p>

<pre><code>User.includes(:posts).where(posts: { name: &#39;example&#39; })
</code></pre>

<p>NOTE: Conditions affect both sides of an association. For example, the above code will return only users that have a post named ‚Äúexample‚Äù, <em>and will only include posts named ‚Äúexample‚Äù</em>, even when a matching user has other additional posts.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 250
def includes(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.includes!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L250" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-invert_where"><code><b>invert_where</b>()</code></h3>

          <div class="description">
<p>Allows you to invert an entire where clause instead of manually applying conditions.</p>

<pre><code>class User
  scope :active, -&gt; { where(accepted: true, locked: false) }
end

User.where(accepted: true)
# WHERE `accepted` = 1

User.where(accepted: true).invert_where
# WHERE `accepted` != 1

User.active
# WHERE `accepted` = 1 AND `locked` = 0

User.active.invert_where
# WHERE NOT (`accepted` = 1 AND `locked` = 0)
</code></pre>

<p>Be careful because this inverts all conditions before <a href="QueryMethods.html#method-i-invert_where"><code>invert_where</code></a> call.</p>

<pre><code>class User
  scope :active, -&gt; { where(accepted: true, locked: false) }
  scope :inactive, -&gt; { active.invert_where } # Do not attempt it
end

# It also inverts `where(role: &#39;admin&#39;)` unexpectedly.
User.where(role: &#39;admin&#39;).inactive
# WHERE NOT (`role` = &#39;admin&#39; AND `accepted` = 1 AND `locked` = 0)
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1101
def invert_where
  spawn.invert_where!
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1101" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-joins"><code><b>joins</b>(*args)</code></h3>

          <div class="description">
<p>Performs JOINs on <code>args</code>. The given symbol(s) should match the name of the association(s).</p>

<pre><code>User.joins(:posts)
# SELECT &quot;users&quot;.*
# FROM &quot;users&quot;
# INNER JOIN &quot;posts&quot; ON &quot;posts&quot;.&quot;user_id&quot; = &quot;users&quot;.&quot;id&quot;
</code></pre>

<p>Multiple joins:</p>

<pre><code>User.joins(:posts, :account)
# SELECT &quot;users&quot;.*
# FROM &quot;users&quot;
# INNER JOIN &quot;posts&quot; ON &quot;posts&quot;.&quot;user_id&quot; = &quot;users&quot;.&quot;id&quot;
# INNER JOIN &quot;accounts&quot; ON &quot;accounts&quot;.&quot;id&quot; = &quot;users&quot;.&quot;account_id&quot;
</code></pre>

<p>Nested joins:</p>

<pre><code>User.joins(posts: [:comments])
# SELECT &quot;users&quot;.*
# FROM &quot;users&quot;
# INNER JOIN &quot;posts&quot; ON &quot;posts&quot;.&quot;user_id&quot; = &quot;users&quot;.&quot;id&quot;
# INNER JOIN &quot;comments&quot; ON &quot;comments&quot;.&quot;post_id&quot; = &quot;posts&quot;.&quot;id&quot;
</code></pre>

<p>You can use strings in order to customize your joins:</p>

<pre><code>User.joins(&quot;LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = &#39;Post&#39; AND bookmarks.user_id = users.id&quot;)
# SELECT &quot;users&quot;.* FROM &quot;users&quot; LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = &#39;Post&#39; AND bookmarks.user_id = users.id
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 868
def joins(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.joins!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L868" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-left_joins"><code><b>left_joins</b>(*args)</code></h3>

          

          

          
            <p class="method__aka">
              Alias for:
              <a href="/classes/ActiveRecord/QueryMethods.html#method-i-left_outer_joins" class="ref-link"><code>left_outer_joins</code></a>.
            </p>
          

          
          
        </div>
        
        <div class="method">
          <h3 id="method-i-left_outer_joins"><code><b>left_outer_joins</b>(*args)</code></h3>

          <div class="description">
<p>Performs LEFT OUTER JOINs on <code>args</code>:</p>

<pre><code>User.left_outer_joins(:posts)
# SELECT &quot;users&quot;.* FROM &quot;users&quot; LEFT OUTER JOIN &quot;posts&quot; ON &quot;posts&quot;.&quot;user_id&quot; = &quot;users&quot;.&quot;id&quot;
</code></pre>
</div>

          
            <p class="method__aka">
              Also aliased as:
              
              <a href="/classes/ActiveRecord/QueryMethods.html#method-i-left_joins" class="ref-link"><code>left_joins</code></a>.
            </p>
          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 883
def left_outer_joins(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.left_outer_joins!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L883" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-limit"><code><b>limit</b>(value)</code></h3>

          <div class="description">
<p>Specifies a limit for the number of records to retrieve.</p>

<pre><code>User.limit(10) # generated SQL has &#39;LIMIT 10&#39;

User.limit(10).limit(20) # generated SQL has &#39;LIMIT 20&#39;
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1211
def limit(value)
  spawn.limit!(value)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1211" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-lock"><code><b>lock</b>(locks = true)</code></h3>

          <div class="description">
<p>Specifies locking settings (default to <code>true</code>). For more information on locking, please see <a href="Locking.html"><code>ActiveRecord::Locking</code></a>.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1239
def lock(locks = true)
  spawn.lock!(locks)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1239" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-none"><code><b>none</b>()</code></h3>

          <div class="description">
<p>Returns a chainable relation with zero records.</p>

<p>The returned relation implements the Null <a href="../Object.html"><code>Object</code></a> pattern. It is an object with defined null behavior and always returns an empty array of records without querying the database.</p>

<p>Any subsequent condition chained to the returned relation will continue generating an empty relation and will not fire any query to the database.</p>

<p>Used in cases where a method or scope could return zero records but the result needs to be chainable.</p>

<p>For example:</p>

<pre><code>@posts = current_user.visible_posts.where(name: params[:name])
# the visible_posts method is expected to return a chainable Relation

def visible_posts
  case role
  when &#39;Country Manager&#39;
    Post.where(country: country)
  when &#39;Reviewer&#39;
    Post.published
  when &#39;Bad User&#39;
    Post.none # It can&#39;t be chained if [] is returned.
  end
end
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1282
def none
  spawn.none!
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1282" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-offset"><code><b>offset</b>(value)</code></h3>

          <div class="description">
<p>Specifies the number of rows to skip before returning rows.</p>

<pre><code>User.offset(10) # generated SQL has &quot;OFFSET 10&quot;
</code></pre>

<p>Should be used with order.</p>

<pre><code>User.offset(10).order(&quot;name ASC&quot;)
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1228
def offset(value)
  spawn.offset!(value)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1228" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-optimizer_hints"><code><b>optimizer_hints</b>(*args)</code></h3>

          <div class="description">
<p>Specify optimizer hints to be used in the SELECT statement.</p>

<p>Example (for MySQL):</p>

<pre><code>Topic.optimizer_hints(&quot;MAX_EXECUTION_TIME(50000)&quot;, &quot;NO_INDEX_MERGE(topics)&quot;)
# SELECT /*+ MAX_EXECUTION_TIME(50000) NO_INDEX_MERGE(topics) */ `topics`.* FROM `topics`
</code></pre>

<p>Example (for PostgreSQL with pg_hint_plan):</p>

<pre><code>Topic.optimizer_hints(&quot;SeqScan(topics)&quot;, &quot;Parallel(topics 8)&quot;)
# SELECT /*+ SeqScan(topics) Parallel(topics 8) */ &quot;topics&quot;.* FROM &quot;topics&quot;
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1486
def optimizer_hints(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.optimizer_hints!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1486" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-or"><code><b>or</b>(other)</code></h3>

          <div class="description">
<p>Returns a new relation, which is the logical union of this relation and the one passed as an argument.</p>

<p>The two relations must be structurally compatible: they must be scoping the same model, and they must differ only by <a href="QueryMethods.html#method-i-where"><code>where</code></a> (if no <a href="QueryMethods.html#method-i-group"><code>group</code></a> has been defined) or <a href="QueryMethods.html#method-i-having"><code>having</code></a> (if a <a href="QueryMethods.html#method-i-group"><code>group</code></a> is present).</p>

<pre><code>Post.where(&quot;id = 1&quot;).or(Post.where(&quot;author_id = 3&quot;))
# SELECT `posts`.* FROM `posts` WHERE ((id = 1) OR (author_id = 3))
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1167
def or(other)
  if other.is_a?(Relation)
    if @none
      other.spawn
    else
      spawn.or!(other)
    end
  else
    raise ArgumentError, &quot;You have passed #{other.class.name} object to #or. Pass an ActiveRecord::Relation object instead.&quot;
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1167" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-order"><code><b>order</b>(*args)</code></h3>

          <div class="description">
<p>Applies an <code>ORDER BY</code> clause to a query.</p>

<p><a href="QueryMethods.html#method-i-order"><code>order</code></a> accepts arguments in one of several formats.</p>

<h3 id="method-i-order-label-symbols">symbols</h3>

<p>The symbol represents the name of the column you want to order the results by.</p>

<pre><code>User.order(:name)
# SELECT &quot;users&quot;.* FROM &quot;users&quot; ORDER BY &quot;users&quot;.&quot;name&quot; ASC
</code></pre>

<p>By default, the order is ascending. If you want descending order, you can map the column name symbol to <code>:desc</code>.</p>

<pre><code>User.order(email: :desc)
# SELECT &quot;users&quot;.* FROM &quot;users&quot; ORDER BY &quot;users&quot;.&quot;email&quot; DESC
</code></pre>

<p>Multiple columns can be passed this way, and they will be applied in the order specified.</p>

<pre><code>User.order(:name, email: :desc)
# SELECT &quot;users&quot;.* FROM &quot;users&quot; ORDER BY &quot;users&quot;.&quot;name&quot; ASC, &quot;users&quot;.&quot;email&quot; DESC
</code></pre>

<h3 id="method-i-order-label-strings">strings</h3>

<p>Strings are passed directly to the database, allowing you to specify simple SQL expressions.</p>

<p>This could be a source of SQL injection, so only strings composed of plain column names and simple <code>function(column_name)</code> expressions with optional <code>ASC</code>/<code>DESC</code> modifiers are allowed.</p>

<pre><code>User.order(&#39;name&#39;)
# SELECT &quot;users&quot;.* FROM &quot;users&quot; ORDER BY name

User.order(&#39;name DESC&#39;)
# SELECT &quot;users&quot;.* FROM &quot;users&quot; ORDER BY name DESC

User.order(&#39;name DESC, email&#39;)
# SELECT &quot;users&quot;.* FROM &quot;users&quot; ORDER BY name DESC, email
</code></pre>

<h3 id="method-i-order-label-Arel"><a href="../Arel.html"><code>Arel</code></a></h3>

<p>If you need to pass in complicated expressions that you have verified are safe for the database, you can use <a href="../Arel.html"><code>Arel</code></a>.</p>

<pre><code>User.order(Arel.sql(&#39;end_date - start_date&#39;))
# SELECT &quot;users&quot;.* FROM &quot;users&quot; ORDER BY end_date - start_date
</code></pre>

<p>Custom query syntax, like JSON columns for PostgreSQL, is supported in this way.</p>

<pre><code>User.order(Arel.sql(&quot;payload-&gt;&gt;&#39;kind&#39;&quot;))
# SELECT &quot;users&quot;.* FROM &quot;users&quot; ORDER BY payload-&gt;&gt;&#39;kind&#39;
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 656
def order(*args)
  check_if_method_has_arguments!(__callee__, args) do
    sanitize_order_arguments(args)
  end
  spawn.order!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L656" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-preload"><code><b>preload</b>(*args)</code></h3>

          <div class="description">
<p>Specify associations <code>args</code> to be eager loaded using separate queries. A separate query is performed for each association.</p>

<pre><code>users = User.preload(:address).limit(5)
users.each do |user|
  user.address.city
end

# SELECT &quot;users&quot;.* FROM &quot;users&quot; LIMIT 5
# SELECT &quot;addresses&quot;.* FROM &quot;addresses&quot; WHERE &quot;addresses&quot;.&quot;id&quot; IN (1,2,3,4,5)
</code></pre>

<p>Instead of loading the 5 addresses with 5 separate queries, all addresses are loaded with a separate query.</p>

<p>Loading multiple and nested associations is possible using Hashes and Arrays, similar to <a href="QueryMethods.html#method-i-includes"><code>includes</code></a>:</p>

<pre><code>User.preload(:address, friends: [:address, :followers])
# SELECT &quot;users&quot;.* FROM &quot;users&quot;
# SELECT &quot;addresses&quot;.* FROM &quot;addresses&quot; WHERE &quot;addresses&quot;.&quot;id&quot; IN (1,2,3,4,5)
# SELECT &quot;friends&quot;.* FROM &quot;friends&quot; WHERE &quot;friends&quot;.&quot;user_id&quot; IN (1,2,3,4,5)
# SELECT ...
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 322
def preload(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.preload!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L322" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-readonly"><code><b>readonly</b>(value = true)</code></h3>

          <div class="description">
<p>Mark a relation as readonly. Attempting to update a record will result in an error.</p>

<pre><code>users = User.readonly
users.first.save
# =&gt; ActiveRecord::ReadOnlyRecord: User is marked as readonly
</code></pre>

<p>To make a readonly relation writable, pass <code>false</code>.</p>

<pre><code>users.readonly(false)
users.first.save
# =&gt; true
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1310
def readonly(value = true)
  spawn.readonly!(value)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1310" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-references"><code><b>references</b>(*table_names)</code></h3>

          <div class="description">
<p>Use to indicate that the given <code>table_names</code> are referenced by an SQL string, and should therefore be +JOIN+ed in any query rather than loaded separately. This method only works in conjunction with <a href="QueryMethods.html#method-i-includes"><code>includes</code></a>. See <a href="QueryMethods.html#method-i-includes"><code>includes</code></a> for more details.</p>

<pre><code>User.includes(:posts).where(&quot;posts.name = &#39;foo&#39;&quot;)
# Doesn&#39;t JOIN the posts table, resulting in an error.

User.includes(:posts).where(&quot;posts.name = &#39;foo&#39;&quot;).references(:posts)
# Query now knows the string references posts, so adds a JOIN
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 355
def references(*table_names)
  check_if_method_has_arguments!(__callee__, table_names)
  spawn.references!(*table_names)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L355" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-regroup"><code><b>regroup</b>(*args)</code></h3>

          <div class="description">
<p>Allows you to change a previously set group statement.</p>

<pre><code>Post.group(:title, :body)
# SELECT `posts`.`*` FROM `posts` GROUP BY `posts`.`title`, `posts`.`body`

Post.group(:title, :body).regroup(:title)
# SELECT `posts`.`*` FROM `posts` GROUP BY `posts`.`title`
</code></pre>

<p>This is short-hand for <code>unscope(:group).group(fields)</code>. Note that we‚Äôre unscoping the entire group statement.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 593
def regroup(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.regroup!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L593" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-reorder"><code><b>reorder</b>(*args)</code></h3>

          <div class="description">
<p>Replaces any existing order defined on the relation with the specified order.</p>

<pre><code>User.order(&#39;email DESC&#39;).reorder(&#39;id ASC&#39;) # generated SQL has &#39;ORDER BY id ASC&#39;
</code></pre>

<p>Subsequent calls to order on the same relation will be appended. For example:</p>

<pre><code>User.order(&#39;email DESC&#39;).reorder(&#39;id ASC&#39;).order(&#39;name ASC&#39;)
</code></pre>

<p>generates a query with <code>ORDER BY id ASC, name ASC</code>.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 752
def reorder(*args)
  check_if_method_has_arguments!(__callee__, args) do
    sanitize_order_arguments(args)
  end
  spawn.reorder!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L752" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-reselect"><code><b>reselect</b>(*args)</code></h3>

          <div class="description">
<p>Allows you to change a previously set select statement.</p>

<pre><code>Post.select(:title, :body)
# SELECT `posts`.`title`, `posts`.`body` FROM `posts`

Post.select(:title, :body).reselect(:created_at)
# SELECT `posts`.`created_at` FROM `posts`
</code></pre>

<p>This is short-hand for <code>unscope(:select).select(fields)</code>. Note that we‚Äôre unscoping the entire select statement.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 541
def reselect(*args)
  check_if_method_has_arguments!(__callee__, args)
  args = process_select_args(args)
  spawn.reselect!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L541" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-reverse_order"><code><b>reverse_order</b>()</code></h3>

          <div class="description">
<p>Reverse the existing order clause on the relation.</p>

<pre><code>User.order(&#39;name ASC&#39;).reverse_order # generated SQL has &#39;ORDER BY name DESC&#39;
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1499
def reverse_order
  spawn.reverse_order!
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1499" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-rewhere"><code><b>rewhere</b>(conditions)</code></h3>

          <div class="description">
<p>Allows you to change a previously set where condition for a given attribute, instead of appending to that condition.</p>

<pre><code>Post.where(trashed: true).where(trashed: false)
# WHERE `trashed` = 1 AND `trashed` = 0

Post.where(trashed: true).rewhere(trashed: false)
# WHERE `trashed` = 0

Post.where(active: true).where(trashed: true).rewhere(trashed: false)
# WHERE `active` = 1 AND `trashed` = 0
</code></pre>

<p>This is short-hand for <code>unscope(where: conditions.keys).where(conditions)</code>. Note that unlike reorder, we‚Äôre only unscoping the named conditions ‚Äì not the entire where statement.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1061
def rewhere(conditions)
  return unscope(:where) if conditions.nil?

  scope = spawn
  where_clause = scope.build_where_clause(conditions)

  scope.unscope!(where: where_clause.extract_attributes)
  scope.where_clause += where_clause
  scope
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1061" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-select"><code><b>select</b>(*fields)</code></h3>

          <div class="description">
<p>Works in two unique ways.</p>

<p>First: takes a block so it can be used just like <code>Array#select</code>.</p>

<pre><code>Model.all.select { |m| m.field == value }
</code></pre>

<p>This will build an array of objects from the database for the scope, converting them into an array and iterating through them using <code>Array#select</code>.</p>

<p>Second: Modifies the SELECT statement for the query so that only certain fields are retrieved:</p>

<pre><code>Model.select(:field)
# =&gt; [#&lt;Model id: nil, field: &quot;value&quot;&gt;]
</code></pre>

<p>Although in the above example it looks as though this method returns an array, it actually returns a relation object and can have other query methods appended to it, such as the other methods in <a href="QueryMethods.html"><code>ActiveRecord::QueryMethods</code></a>.</p>

<p>The argument to the method can also be an array of fields.</p>

<pre><code>Model.select(:field, :other_field, :and_one_more)
# =&gt; [#&lt;Model id: nil, field: &quot;value&quot;, other_field: &quot;value&quot;, and_one_more: &quot;value&quot;&gt;]
</code></pre>

<p>The argument also can be a hash of fields and aliases.</p>

<pre><code>Model.select(models: { field: :alias, other_field: :other_alias })
# =&gt; [#&lt;Model id: nil, alias: &quot;value&quot;, other_alias: &quot;value&quot;&gt;]

Model.select(models: [:field, :other_field])
# =&gt; [#&lt;Model id: nil, field: &quot;value&quot;, other_field: &quot;value&quot;&gt;]
</code></pre>

<p>You can also use one or more strings, which will be used unchanged as SELECT fields.</p>

<pre><code>Model.select(&#39;field AS field_one&#39;, &#39;other_field AS field_two&#39;)
# =&gt; [#&lt;Model id: nil, field_one: &quot;value&quot;, field_two: &quot;value&quot;&gt;]
</code></pre>

<p>If an alias was specified, it will be accessible from the resulting objects:</p>

<pre><code>Model.select(&#39;field AS field_one&#39;).first.field_one
# =&gt; &quot;value&quot;
</code></pre>

<p>Accessing attributes of an object that do not have fields retrieved by a select except <code>id</code> will throw <a href="../ActiveModel/MissingAttributeError.html"><code>ActiveModel::MissingAttributeError</code></a>:</p>

<pre><code>Model.select(:field).first.other_field
# =&gt; ActiveModel::MissingAttributeError: missing attribute &#39;other_field&#39; for Model
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 413
def select(*fields)
  if block_given?
    if fields.any?
      raise ArgumentError, &quot;`select&#39; with block doesn&#39;t take arguments.&quot;
    end

    return super()
  end

  check_if_method_has_arguments!(__callee__, fields, &quot;Call `select&#39; with at least one field.&quot;)

  fields = process_select_args(fields)
  spawn._select!(*fields)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L413" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-strict_loading"><code><b>strict_loading</b>(value = true)</code></h3>

          <div class="description">
<p>Sets the returned relation to <a href="QueryMethods.html#method-i-strict_loading"><code>strict_loading</code></a> mode. This will raise an error if the record tries to lazily load an association.</p>

<pre><code>user = User.strict_loading.first
user.comments.to_a
# =&gt; ActiveRecord::StrictLoadingViolationError
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1325
def strict_loading(value = true)
  spawn.strict_loading!(value)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1325" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-structurally_compatible-3F"><code><b>structurally_compatible?</b>(other)</code></h3>

          <div class="description">
<p>Checks whether the given relation is structurally compatible with this relation, to determine if it‚Äôs possible to use the <a href="QueryMethods.html#method-i-and"><code>and</code></a> and <a href="QueryMethods.html#method-i-or"><code>or</code></a> methods without raising an error. Structurally compatible is defined as: they must be scoping the same model, and they must differ only by <a href="QueryMethods.html#method-i-where"><code>where</code></a> (if no <a href="QueryMethods.html#method-i-group"><code>group</code></a> has been defined) or <a href="QueryMethods.html#method-i-having"><code>having</code></a> (if a <a href="QueryMethods.html#method-i-group"><code>group</code></a> is present).</p>

<pre><code>Post.where(&quot;id = 1&quot;).structurally_compatible?(Post.where(&quot;author_id = 3&quot;))
# =&gt; true

Post.joins(:comments).structurally_compatible?(Post.where(&quot;id = 1&quot;))
# =&gt; false
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1121
def structurally_compatible?(other)
  structurally_incompatible_values_for(other).empty?
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1121" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-uniq-21"><code><b>uniq!</b>(name)</code></h3>

          <div class="description">
<p>Deduplicate multiple values.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1542
def uniq!(name)
  if values = @values[name]
    values.uniq! if values.is_a?(Array) &amp;&amp; !values.empty?
  end
  self
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1542" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-unscope"><code><b>unscope</b>(*args)</code></h3>

          <div class="description">
<p>Removes an unwanted relation that is already defined on a chain of relations. This is useful when passing around chains of relations and would like to modify the relations without reconstructing the entire chain.</p>

<pre><code>User.order(&#39;email DESC&#39;).unscope(:order) == User.all
</code></pre>

<p>The method arguments are symbols which correspond to the names of the methods which should be unscoped. The valid arguments are given in <a href="QueryMethods.html#VALID_UNSCOPING_VALUES"><code>VALID_UNSCOPING_VALUES</code></a>. The method can also be called with multiple arguments. For example:</p>

<pre><code>User.order(&#39;email DESC&#39;).select(&#39;id&#39;).where(name: &quot;John&quot;)
    .unscope(:order, :select, :where) == User.all
</code></pre>

<p>One can additionally pass a hash as an argument to unscope specific <code>:where</code> values. This is done by passing a hash with a single key-value pair. The key should be <code>:where</code> and the value should be the where value to unscope. For example:</p>

<pre><code>User.where(name: &quot;John&quot;, active: true).unscope(where: :name)
    == User.where(active: true)
</code></pre>

<p>This method is similar to except, but unlike except, it persists across merges:</p>

<pre><code>User.order(&#39;email&#39;).merge(User.except(:order))
    == User.order(&#39;email&#39;)

User.order(&#39;email&#39;).merge(User.unscope(:order))
    == User.all
</code></pre>

<p>This means it can be used in association definitions:</p>

<pre><code>has_many :comments, -&gt; { unscope(where: :trashed) }
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 806
def unscope(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.unscope!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L806" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-where"><code><b>where</b>(*args)</code></h3>

          <div class="description">
<p>Returns a new relation, which is the result of filtering the current relation according to the conditions in the arguments.</p>

<p><a href="QueryMethods.html#method-i-where"><code>where</code></a> accepts conditions in one of several formats. In the examples below, the resulting SQL is given as an illustration; the actual query generated may be different depending on the database adapter.</p>

<h3 id="method-i-where-label-String">String</h3>

<p>A single string, without additional arguments, is passed to the query constructor as an SQL fragment, and used in the where clause of the query.</p>

<pre><code>Client.where(&quot;orders_count = &#39;2&#39;&quot;)
# SELECT * from clients where orders_count = &#39;2&#39;;
</code></pre>

<p>Note that building your own string from user input may expose your application to injection attacks if not done properly. As an alternative, it is recommended to use one of the following methods.</p>

<h3 id="method-i-where-label-Array">Array</h3>

<p>If an array is passed, then the first element of the array is treated as a template, and the remaining elements are inserted into the template to generate the condition. Active Record takes care of building the query to avoid injection attacks, and will convert from the ruby type to the database type where needed. Elements are inserted into the string in the order in which they appear.</p>

<pre><code>User.where([&quot;name = ? and email = ?&quot;, &quot;Joe&quot;, &quot;joe@example.com&quot;])
# SELECT * FROM users WHERE name = &#39;Joe&#39; AND email = &#39;joe@example.com&#39;;
</code></pre>

<p>Alternatively, you can use named placeholders in the template, and pass a hash as the second element of the array. The names in the template are replaced with the corresponding values from the hash.</p>

<pre><code>User.where([&quot;name = :name and email = :email&quot;, { name: &quot;Joe&quot;, email: &quot;joe@example.com&quot; }])
# SELECT * FROM users WHERE name = &#39;Joe&#39; AND email = &#39;joe@example.com&#39;;
</code></pre>

<p>This can make for more readable code in complex queries.</p>

<p>Lastly, you can use sprintf-style % escapes in the template. This works slightly differently than the previous methods; you are responsible for ensuring that the values in the template are properly quoted. The values are passed to the connector for quoting, but the caller is responsible for ensuring they are enclosed in quotes in the resulting SQL. After quoting, the values are inserted using the same escapes as the Ruby core method <code>Kernel::sprintf</code>.</p>

<pre><code>User.where([&quot;name = &#39;%s&#39; and email = &#39;%s&#39;&quot;, &quot;Joe&quot;, &quot;joe@example.com&quot;])
# SELECT * FROM users WHERE name = &#39;Joe&#39; AND email = &#39;joe@example.com&#39;;
</code></pre>

<p>If <a href="QueryMethods.html#method-i-where"><code>where</code></a> is called with multiple arguments, these are treated as if they were passed as the elements of a single array.</p>

<pre><code>User.where(&quot;name = :name and email = :email&quot;, { name: &quot;Joe&quot;, email: &quot;joe@example.com&quot; })
# SELECT * FROM users WHERE name = &#39;Joe&#39; AND email = &#39;joe@example.com&#39;;
</code></pre>

<p>When using strings to specify conditions, you can use any operator available from the database. While this provides the most flexibility, you can also unintentionally introduce dependencies on the underlying database. If your code is intended for general consumption, test with multiple database backends.</p>

<h3 id="method-i-where-label-Hash">Hash</h3>

<p><a href="QueryMethods.html#method-i-where"><code>where</code></a> will also accept a hash condition, in which the keys are fields and the values are values to be searched for.</p>

<p>Fields can be symbols or strings. Values can be single values, arrays, or ranges.</p>

<pre><code>User.where(name: &quot;Joe&quot;, email: &quot;joe@example.com&quot;)
# SELECT * FROM users WHERE name = &#39;Joe&#39; AND email = &#39;joe@example.com&#39;

User.where(name: [&quot;Alice&quot;, &quot;Bob&quot;])
# SELECT * FROM users WHERE name IN (&#39;Alice&#39;, &#39;Bob&#39;)

User.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
# SELECT * FROM users WHERE (created_at BETWEEN &#39;2012-06-09 07:00:00.000000&#39; AND &#39;2012-06-10 07:00:00.000000&#39;)
</code></pre>

<p>In the case of a belongs_to relationship, an association key can be used to specify the model if an <a href="../ActiveRecord.html"><code>ActiveRecord</code></a> object is used as the value.</p>

<pre><code>author = Author.find(1)

# The following queries will be equivalent:
Post.where(author: author)
Post.where(author_id: author)
</code></pre>

<p>This also works with polymorphic belongs_to relationships:</p>

<pre><code>treasure = Treasure.create(name: &#39;gold coins&#39;)
treasure.price_estimates &lt;&lt; PriceEstimate.create(price: 125)

# The following queries will be equivalent:
PriceEstimate.where(estimate_of: treasure)
PriceEstimate.where(estimate_of_type: &#39;Treasure&#39;, estimate_of_id: treasure)
</code></pre>

<p><a href="../Hash.html"><code>Hash</code></a> conditions may also be specified in a tuple-like syntax. <a href="../Hash.html"><code>Hash</code></a> keys may be an array of columns with an array of tuples as values.</p>

<pre><code>Article.where([:author_id, :id] =&gt; [[15, 1], [15, 2]])
# SELECT * FROM articles WHERE author_id = 15 AND id = 1 OR author_id = 15 AND id = 2
</code></pre>

<h3 id="method-i-where-label-Joins">Joins</h3>

<p>If the relation is the result of a join, you may create a condition which uses any of the tables in the join. For string and array conditions, use the table name in the condition.</p>

<pre><code>User.joins(:posts).where(&quot;posts.created_at &lt; ?&quot;, Time.now)
</code></pre>

<p>For hash conditions, you can either use the table name in the key, or use a sub-hash.</p>

<pre><code>User.joins(:posts).where(&quot;posts.published&quot; =&gt; true)
User.joins(:posts).where(posts: { published: true })
</code></pre>

<h3 id="method-i-where-label-No+Argument">No Argument</h3>

<p>If no argument is passed, <a href="QueryMethods.html#method-i-where"><code>where</code></a> returns a new instance of <a href="QueryMethods/WhereChain.html"><code>WhereChain</code></a>, that can be chained with <a href="QueryMethods/WhereChain.html#method-i-not"><code>WhereChain#not</code></a>, <a href="QueryMethods/WhereChain.html#method-i-missing"><code>WhereChain#missing</code></a>, or <a href="QueryMethods/WhereChain.html#method-i-associated"><code>WhereChain#associated</code></a>.</p>

<p>Chaining with <a href="QueryMethods/WhereChain.html#method-i-not"><code>WhereChain#not</code></a>:</p>

<pre><code>User.where.not(name: &quot;Jon&quot;)
# SELECT * FROM users WHERE name != &#39;Jon&#39;
</code></pre>

<p>Chaining with <a href="QueryMethods/WhereChain.html#method-i-associated"><code>WhereChain#associated</code></a>:</p>

<pre><code>Post.where.associated(:author)
# SELECT &quot;posts&quot;.* FROM &quot;posts&quot;
# INNER JOIN &quot;authors&quot; ON &quot;authors&quot;.&quot;id&quot; = &quot;posts&quot;.&quot;author_id&quot;
# WHERE &quot;authors&quot;.&quot;id&quot; IS NOT NULL
</code></pre>

<p>Chaining with <a href="QueryMethods/WhereChain.html#method-i-missing"><code>WhereChain#missing</code></a>:</p>

<pre><code>Post.where.missing(:author)
# SELECT &quot;posts&quot;.* FROM &quot;posts&quot;
# LEFT OUTER JOIN &quot;authors&quot; ON &quot;authors&quot;.&quot;id&quot; = &quot;posts&quot;.&quot;author_id&quot;
# WHERE &quot;authors&quot;.&quot;id&quot; IS NULL
</code></pre>

<h3 id="method-i-where-label-Blank+Condition">Blank Condition</h3>

<p>If the condition is any blank-ish object, then <a href="QueryMethods.html#method-i-where"><code>where</code></a> is a no-op and returns the current relation.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 1033
def where(*args)
  if args.empty?
    WhereChain.new(spawn)
  elsif args.length == 1 &amp;&amp; args.first.blank?
    self
  else
    spawn.where!(*args)
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L1033" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-with"><code><b>with</b>(*args)</code></h3>

          <div class="description">
<p>Add a Common Table Expression (CTE) that you can then reference within another SELECT statement.</p>

<p>Note: CTE‚Äôs are only supported in MySQL for versions 8.0 and above. You will not be able to use CTE‚Äôs with MySQL 5.7.</p>

<pre><code>Post.with(posts_with_tags: Post.where(&quot;tags_count &gt; ?&quot;, 0))
# =&gt; ActiveRecord::Relation
# WITH posts_with_tags AS (
#   SELECT * FROM posts WHERE (tags_count &gt; 0)
# )
# SELECT * FROM posts
</code></pre>

<p>You can also pass an array of sub-queries to be joined in a +UNION ALL+.</p>

<pre><code>Post.with(posts_with_tags_or_comments: [Post.where(&quot;tags_count &gt; ?&quot;, 0), Post.where(&quot;comments_count &gt; ?&quot;, 0)])
# =&gt; ActiveRecord::Relation
# WITH posts_with_tags_or_comments AS (
#  (SELECT * FROM posts WHERE (tags_count &gt; 0))
#  UNION ALL
#  (SELECT * FROM posts WHERE (comments_count &gt; 0))
# )
# SELECT * FROM posts
</code></pre>

<p>Once you define Common Table Expression you can use custom <code>FROM</code> value or <code>JOIN</code> to reference it.</p>

<pre><code>Post.with(posts_with_tags: Post.where(&quot;tags_count &gt; ?&quot;, 0)).from(&quot;posts_with_tags AS posts&quot;)
# =&gt; ActiveRecord::Relation
# WITH posts_with_tags AS (
#  SELECT * FROM posts WHERE (tags_count &gt; 0)
# )
# SELECT * FROM posts_with_tags AS posts

Post.with(posts_with_tags: Post.where(&quot;tags_count &gt; ?&quot;, 0)).joins(&quot;JOIN posts_with_tags ON posts_with_tags.id = posts.id&quot;)
# =&gt; ActiveRecord::Relation
# WITH posts_with_tags AS (
#   SELECT * FROM posts WHERE (tags_count &gt; 0)
# )
# SELECT * FROM posts JOIN posts_with_tags ON posts_with_tags.id = posts.id
</code></pre>

<p>It is recommended to pass a query as <a href="Relation.html"><code>ActiveRecord::Relation</code></a>. If that is not possible and you have verified it is safe for the database, you can pass it as SQL literal using <a href="../Arel.html"><code>Arel</code></a>.</p>

<pre><code>Post.with(popular_posts: Arel.sql(&quot;... complex sql to calculate posts popularity ...&quot;))
</code></pre>

<p>Great caution should be taken to avoid SQL injection vulnerabilities. This method should not be used with unsafe values that include unsanitized input.</p>

<p>To add multiple CTEs just pass multiple key-value pairs</p>

<pre><code>Post.with(
  posts_with_comments: Post.where(&quot;comments_count &gt; ?&quot;, 0),
  posts_with_tags: Post.where(&quot;tags_count &gt; ?&quot;, 0)
)
</code></pre>

<p>or chain multiple <code>.with</code> calls</p>

<pre><code>Post
  .with(posts_with_comments: Post.where(&quot;comments_count &gt; ?&quot;, 0))
  .with(posts_with_tags: Post.where(&quot;tags_count &gt; ?&quot;, 0))
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 493
def with(*args)
  raise ArgumentError, &quot;ActiveRecord::Relation#with does not accept a block&quot; if block_given?
  check_if_method_has_arguments!(__callee__, args)
  spawn.with!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L493" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-with_recursive"><code><b>with_recursive</b>(*args)</code></h3>

          <div class="description">
<p>Add a recursive Common Table Expression (CTE) that you can then reference within another SELECT statement.</p>

<pre><code>Post.with_recursive(post_and_replies: [Post.where(id: 42), Post.joins(&#39;JOIN post_and_replies ON posts.in_reply_to_id = post_and_replies.id&#39;)])
# =&gt; ActiveRecord::Relation
# WITH RECURSIVE post_and_replies AS (
#   (SELECT * FROM posts WHERE id = 42)
#   UNION ALL
#   (SELECT * FROM posts JOIN post_and_replies ON posts.in_reply_to_id = post_and_replies.id)
# )
# SELECT * FROM posts
</code></pre>

<p>See ‚Äò#with` for more information.</p>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">üìù Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 518
def with_recursive(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.with_recursive!(*args)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/1cdd190a25e483b65f1f25bbd0f13a25d696b461/activerecord/lib/active_record/relation/query_methods.rb#L518" target="_blank" class="github_url">üîé See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-without"><code><b>without</b>(*records)</code></h3>

          

          

          
            <p class="method__aka">
              Alias for:
              <a href="/classes/ActiveRecord/QueryMethods.html#method-i-excluding" class="ref-link"><code>excluding</code></a>.
            </p>
          

          
          
        </div>
        
      
    
  
</div>

    </div>
</div>
