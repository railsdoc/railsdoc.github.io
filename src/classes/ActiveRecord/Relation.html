---
title: ActiveRecord::Relation
layout: default
---
<div class="main">
    <div class="banner">
        
            <span>Ruby on Rails 8.0.0</span><br />
        
        <div class="type">Class</div>
        <h1>
            ActiveRecord::Relation
            
                <span class="parent">&lt;
                    
                    <a href="../Object.html">Object</a>
                    
                </span>
            
        </h1>
        <ul class="files">
            
            <li><a href="../../files/activerecord/lib/active_record/relation_rb.html">activerecord/lib/active_record/relation.rb</a></li>
            
            <li><a href="../../files/activerecord/lib/active_record/relation/from_clause_rb.html">activerecord/lib/active_record/relation/from_clause.rb</a></li>
            
            <li><a href="../../files/activerecord/lib/active_record/relation/merger_rb.html">activerecord/lib/active_record/relation/merger.rb</a></li>
            
            <li><a href="../../files/activerecord/lib/active_record/relation/predicate_builder_rb.html">activerecord/lib/active_record/relation/predicate_builder.rb</a></li>
            
            <li><a href="../../files/activerecord/lib/active_record/relation/query_attribute_rb.html">activerecord/lib/active_record/relation/query_attribute.rb</a></li>
            
            <li><a href="../../files/activerecord/lib/active_record/relation/query_methods_rb.html">activerecord/lib/active_record/relation/query_methods.rb</a></li>
            
            <li><a href="../../files/activerecord/lib/active_record/relation/spawn_methods_rb.html">activerecord/lib/active_record/relation/spawn_methods.rb</a></li>
            
            <li><a href="../../files/activerecord/lib/active_record/relation/where_clause_rb.html">activerecord/lib/active_record/relation/where_clause.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="class-ActiveRecord::Relation-label-Active+Record+Relation">Active Record Relation</h1>

    </div>
  

  

  
  


  

  
    <h2 id="methods">Methods</h2>
    <ul>
      
        <li>
          <a href="#method-i-3D-3D">==</a>
        </li>
      
        <li>
          <a href="#method-i-any-3F">any?</a>
        </li>
      
        <li>
          <a href="#method-i-blank-3F">blank?</a>
        </li>
      
        <li>
          <a href="#method-i-build">build</a>
        </li>
      
        <li>
          <a href="#method-i-cache_key">cache_key</a>
        </li>
      
        <li>
          <a href="#method-i-cache_key_with_version">cache_key_with_version</a>
        </li>
      
        <li>
          <a href="#method-i-cache_version">cache_version</a>
        </li>
      
        <li>
          <a href="#method-i-create">create</a>
        </li>
      
        <li>
          <a href="#method-i-create-21">create!</a>
        </li>
      
        <li>
          <a href="#method-i-create_or_find_by">create_or_find_by</a>
        </li>
      
        <li>
          <a href="#method-i-create_or_find_by-21">create_or_find_by!</a>
        </li>
      
        <li>
          <a href="#method-i-delete">delete</a>
        </li>
      
        <li>
          <a href="#method-i-delete_all">delete_all</a>
        </li>
      
        <li>
          <a href="#method-i-delete_by">delete_by</a>
        </li>
      
        <li>
          <a href="#method-i-destroy">destroy</a>
        </li>
      
        <li>
          <a href="#method-i-destroy_all">destroy_all</a>
        </li>
      
        <li>
          <a href="#method-i-destroy_by">destroy_by</a>
        </li>
      
        <li>
          <a href="#method-i-eager_loading-3F">eager_loading?</a>
        </li>
      
        <li>
          <a href="#method-i-empty-3F">empty?</a>
        </li>
      
        <li>
          <a href="#method-i-encode_with">encode_with</a>
        </li>
      
        <li>
          <a href="#method-i-explain">explain</a>
        </li>
      
        <li>
          <a href="#method-i-find_or_create_by">find_or_create_by</a>
        </li>
      
        <li>
          <a href="#method-i-find_or_create_by-21">find_or_create_by!</a>
        </li>
      
        <li>
          <a href="#method-i-find_or_initialize_by">find_or_initialize_by</a>
        </li>
      
        <li>
          <a href="#method-i-initialize_copy">initialize_copy</a>
        </li>
      
        <li>
          <a href="#method-i-insert">insert</a>
        </li>
      
        <li>
          <a href="#method-i-insert-21">insert!</a>
        </li>
      
        <li>
          <a href="#method-i-insert_all">insert_all</a>
        </li>
      
        <li>
          <a href="#method-i-insert_all-21">insert_all!</a>
        </li>
      
        <li>
          <a href="#method-i-inspect">inspect</a>
        </li>
      
        <li>
          <a href="#method-i-joined_includes_values">joined_includes_values</a>
        </li>
      
        <li>
          <a href="#method-i-load">load</a>
        </li>
      
        <li>
          <a href="#method-i-load_async">load_async</a>
        </li>
      
        <li>
          <a href="#method-i-load_records">load_records</a>
        </li>
      
        <li>
          <a href="#method-i-many-3F">many?</a>
        </li>
      
        <li>
          <a href="#method-c-new">new</a>
        </li>
      
        <li>
          <a href="#method-i-new">new</a>
        </li>
      
        <li>
          <a href="#method-i-none-3F">none?</a>
        </li>
      
        <li>
          <a href="#method-i-one-3F">one?</a>
        </li>
      
        <li>
          <a href="#method-i-pretty_print">pretty_print</a>
        </li>
      
        <li>
          <a href="#method-i-readonly-3F">readonly?</a>
        </li>
      
        <li>
          <a href="#method-i-reload">reload</a>
        </li>
      
        <li>
          <a href="#method-i-reset">reset</a>
        </li>
      
        <li>
          <a href="#method-i-scheduled-3F">scheduled?</a>
        </li>
      
        <li>
          <a href="#method-i-scope_for_create">scope_for_create</a>
        </li>
      
        <li>
          <a href="#method-i-scoping">scoping</a>
        </li>
      
        <li>
          <a href="#method-i-size">size</a>
        </li>
      
        <li>
          <a href="#method-i-to_a">to_a</a>
        </li>
      
        <li>
          <a href="#method-i-to_ary">to_ary</a>
        </li>
      
        <li>
          <a href="#method-i-to_sql">to_sql</a>
        </li>
      
        <li>
          <a href="#method-i-touch_all">touch_all</a>
        </li>
      
        <li>
          <a href="#method-i-update_all">update_all</a>
        </li>
      
        <li>
          <a href="#method-i-update_counters">update_counters</a>
        </li>
      
        <li>
          <a href="#method-i-upsert">upsert</a>
        </li>
      
        <li>
          <a href="#method-i-upsert_all">upsert_all</a>
        </li>
      
        <li>
          <a href="#method-i-values">values</a>
        </li>
      
    </ul>
  

  
    <!-- Includes -->
    <h2 id="included-modules">Included Modules</h2>
    <ul>
      
        <li>
          
            <a href="../Enumerable.html">
              Enumerable
            </a>
          
        </li>
      
    </ul>
  

  
    

    

    
      <!-- Section constants -->
      <h2 id="constants">Constants</h2>
      <table border='0' cellpadding='5'>
        
          <tr valign='top'>
            <td class="attr-name">CLAUSE_METHODS</td>
            <td>=</td>
            <td class="attr-value">[:where, :having, :from]</td>
          </tr>
          
        
          <tr valign='top'>
            <td class="attr-name">INVALID_METHODS_FOR_DELETE_ALL</td>
            <td>=</td>
            <td class="attr-value">[:distinct, :with, :with_recursive]</td>
          </tr>
          
        
          <tr valign='top'>
            <td class="attr-name">MULTI_VALUE_METHODS</td>
            <td>=</td>
            <td class="attr-value">[:includes, :eager_load, :preload, :select, :group,
:order, :joins, :left_outer_joins, :references,
:extending, :unscope, :optimizer_hints, :annotate,
:with]</td>
          </tr>
          
        
          <tr valign='top'>
            <td class="attr-name">SINGLE_VALUE_METHODS</td>
            <td>=</td>
            <td class="attr-value">[:limit, :offset, :lock, :readonly, :reordering, :strict_loading,
:reverse_order, :distinct, :create_with, :skip_query_cache]</td>
          </tr>
          
        
          <tr valign='top'>
            <td class="attr-name">VALUE_METHODS</td>
            <td>=</td>
            <td class="attr-value">MULTI_VALUE_METHODS + SINGLE_VALUE_METHODS + CLAUSE_METHODS</td>
          </tr>
          
        
      </table>
    

    
      <!-- Section attributes -->
      <h2 id="attributes">Attributes</h2>
      <table border='0' cellpadding='5'>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>klass</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>loaded</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>loaded?</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>model</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>predicate_builder</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [RW]
            </td>
            <td class='attr-name'>skip_preloading_value</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>table</td>
            <td class='attr-desc'></td>
          </tr>
        
      </table>
    

    <!-- Methods -->
    
      <h2 id="class-public-methods">Class Public methods</h2>
      
        <div class="method">
          <h3 id="method-c-new">
            
              new(model, table: nil, predicate_builder: nil, values: {})
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 77
    def initialize(model, table: nil, predicate_builder: nil, values: {})
      if table
        predicate_builder ||= model.predicate_builder.with(TableMetadata.new(model, table))
      else
        table = model.arel_table
        predicate_builder ||= model.predicate_builder
      end

      @model  = model
      @table  = table
      @values = values
      @loaded = false
      @predicate_builder = predicate_builder
      @delegate_to_model = false
      @future_result = nil
      @records = nil
      @async = false
      @none = false
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L77" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
      
    
      <h2 id="instance-public-methods">Instance Public methods</h2>
      
        <div class="method">
          <h3 id="method-i-3D-3D">
            
              ==(other)
            
          </h3>

          
            <div class="description">
              <p>Compares two relations for equality.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1253
    def ==(other)
      case other
      when Associations::CollectionProxy, AssociationRelation
        self == other.records
      when Relation
        other.to_sql == to_sql
      when Array
        records == other
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1253" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-any-3F">
            
              any?(*args)
            
          </h3>

          
            <div class="description">
              <p>Returns true if there are any records.</p>

<p>When a pattern argument is given, this method checks whether elements in the <a href="../Enumerable.html"><code>Enumerable</code></a> match the pattern via the case-equality operator (<code>===</code>).</p>

<pre><code>posts.any?(Post) # =&gt; true or false
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 391
    def any?(*args)
      return false if @none

      return super if args.present? || block_given?
      !empty?
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L391" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-blank-3F">
            
              blank?()
            
          </h3>

          
            <div class="description">
              <p>Returns true if relation is blank.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1274
    def blank?
      records.blank?
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1274" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-build">
            
              build(attributes = nil, &amp;block)
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          
            <div class="aka">
              Alias for: <a href="Relation.html#method-i-new">new</a>
            </div>
          

          
          
        </div>
        
        <div class="method">
          <h3 id="method-i-cache_key">
            
              cache_key(timestamp_column = &quot;updated_at&quot;)
            
          </h3>

          
            <div class="description">
              <p>Returns a stable cache key that can be used to identify this query. The cache key is built with a fingerprint of the SQL query.</p>

<pre><code>Product.where(&quot;name like ?&quot;, &quot;%Cosmic Encounter%&quot;).cache_key
# =&gt; &quot;products/query-1850ab3d302391b85b8693e941286659&quot;
</code></pre>

<p>If <a href="Integration.html#method-c-collection_cache_versioning"><code>ActiveRecord::Base.collection_cache_versioning</code></a> is turned off, as it was in Rails 6.0 and earlier, the cache key will also include a version.</p>

<pre><code>ActiveRecord::Base.collection_cache_versioning = false
Product.where(&quot;name like ?&quot;, &quot;%Cosmic Encounter%&quot;).cache_key
# =&gt; &quot;products/query-1850ab3d302391b85b8693e941286659-1-20150714212553907087000&quot;
</code></pre>

<p>You can also pass a custom timestamp column to fetch the timestamp of the last updated record.</p>

<pre><code>Product.where(&quot;name like ?&quot;, &quot;%Game%&quot;).cache_key(:last_reviewed_at)
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 438
    def cache_key(timestamp_column = &quot;updated_at&quot;)
      @cache_keys ||= {}
      @cache_keys[timestamp_column] ||= model.collection_cache_key(self, timestamp_column)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L438" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-cache_key_with_version">
            
              cache_key_with_version()
            
          </h3>

          
            <div class="description">
              <p>Returns a cache key along with the version.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 519
    def cache_key_with_version
      if version = cache_version
        &quot;#{cache_key}-#{version}&quot;
      else
        cache_key
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L519" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-cache_version">
            
              cache_version(timestamp_column = :updated_at)
            
          </h3>

          
            <div class="description">
              <p>Returns a cache version that can be used together with the cache key to form a recyclable caching scheme. The cache version is built with the number of records matching the query, and the timestamp of the last updated record. When a new record comes to match the query, or any of the existing records is updated or deleted, the cache version changes.</p>

<p>If the collection is loaded, the method will iterate through the records to generate the timestamp, otherwise it will trigger one SQL query like:</p>

<pre><code>SELECT COUNT(*), MAX(&quot;products&quot;.&quot;updated_at&quot;) FROM &quot;products&quot; WHERE (name like &#39;%Cosmic Encounter%&#39;)
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 465
    def cache_version(timestamp_column = :updated_at)
      if model.collection_cache_versioning
        @cache_versions ||= {}
        @cache_versions[timestamp_column] ||= compute_cache_version(timestamp_column)
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L465" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-create">
            
              create(attributes = nil, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Tries to create a new record with the same scoped attributes defined in the relation. Returns the initialized object if validation fails.</p>

<p>Expects arguments in the same format as <a href="Persistence/ClassMethods.html#method-i-create">ActiveRecord::Base.create</a>.</p>

<h4 id="method-i-create-label-Examples">Examples</h4>

<pre><code>users = User.where(name: &#39;Oscar&#39;)
users.create # =&gt; #&lt;User id: 3, name: &quot;Oscar&quot;, ...&gt;

users.create(name: &#39;fxn&#39;)
users.create # =&gt; #&lt;User id: 4, name: &quot;fxn&quot;, ...&gt;

users.create { |user| user.name = &#39;tenderlove&#39; }
# =&gt; #&lt;User id: 5, name: &quot;tenderlove&quot;, ...&gt;

users.create(name: nil) # validation on name
# =&gt; #&lt;User id: nil, name: nil, ...&gt;
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 154
    def create(attributes = nil, &amp;block)
      if attributes.is_a?(Array)
        attributes.collect { |attr| create(attr, &amp;block) }
      else
        block = current_scope_restoring_block(&amp;block)
        scoping { _create(attributes, &amp;block) }
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L154" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-create-21">
            
              create!(attributes = nil, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Similar to <a href="Relation.html#method-i-create"><code>create</code></a>, but calls <a href="Persistence/ClassMethods.html#method-i-create-21">create!</a> on the base class. Raises an exception if a validation error occurs.</p>

<p>Expects arguments in the same format as <a href="Persistence/ClassMethods.html#method-i-create-21">ActiveRecord::Base.create!</a>.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 169
    def create!(attributes = nil, &amp;block)
      if attributes.is_a?(Array)
        attributes.collect { |attr| create!(attr, &amp;block) }
      else
        block = current_scope_restoring_block(&amp;block)
        scoping { _create!(attributes, &amp;block) }
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L169" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-create_or_find_by">
            
              create_or_find_by(attributes, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Attempts to create a record with the given attributes in a table that has a unique database constraint on one or several of its columns. If a row already exists with one or several of these unique constraints, the exception such an insertion would normally raise is caught, and the existing record with those attributes is found using find_by!.</p>

<p>This is similar to <a href="Relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a>, but tries to create the record first. As such it is better suited for cases where the record is most likely not to exist yet.</p>

<p>There are several drawbacks to <a href="Relation.html#method-i-create_or_find_by"><code>create_or_find_by</code></a>, though:</p>
<ul><li>
<p>The underlying table must have the relevant columns defined with unique database constraints.</p>
</li><li>
<p>A unique constraint violation may be triggered by only one, or at least less than all, of the given attributes. This means that the subsequent find_by! may fail to find a matching record, which will then raise an <a href="RecordNotFound.html"><code>ActiveRecord::RecordNotFound</code></a> exception, rather than a record with the given attributes.</p>
</li><li>
<p>While we avoid the race condition between SELECT -&gt; INSERT from <a href="Relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a>, we actually have another race condition between INSERT -&gt; SELECT, which can be triggered if a DELETE between those two statements is run by another client. But for most applications, that’s a significantly less likely condition to hit.</p>
</li><li>
<p>It relies on exception handling to handle control flow, which may be marginally slower.</p>
</li><li>
<p>The primary key may auto-increment on each create, even if it fails. This can accelerate the problem of running out of integers, if the underlying table is still stuck on a primary key of type int (note: All Rails apps since 5.1+ have defaulted to bigint, which is not liable to this problem).</p>
</li><li>
<p>Columns with unique database constraints should not have uniqueness validations defined, otherwise <a href="Relation.html#method-i-create"><code>create</code></a> will fail due to validation errors and find_by will never be called.</p>
</li></ul>

<p>This method will return a record if all given attributes are covered by unique constraints (unless the INSERT -&gt; DELETE -&gt; SELECT race condition is triggered), but if creation was attempted and failed due to validation errors it won’t be persisted, you get what <a href="Relation.html#method-i-create"><code>create</code></a> returns in such situation.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 273
    def create_or_find_by(attributes, &amp;block)
      with_connection do |connection|
        transaction(requires_new: true) { create(attributes, &amp;block) }
      rescue ActiveRecord::RecordNotUnique
        if connection.transaction_open?
          where(attributes).lock.find_by!(attributes)
        else
          find_by!(attributes)
        end
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L273" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-create_or_find_by-21">
            
              create_or_find_by!(attributes, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Like <a href="Relation.html#method-i-create_or_find_by"><code>create_or_find_by</code></a>, but calls <a href="Persistence/ClassMethods.html#method-i-create-21">create!</a> so an exception is raised if the created record is invalid.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 288
    def create_or_find_by!(attributes, &amp;block)
      with_connection do |connection|
        transaction(requires_new: true) { create!(attributes, &amp;block) }
      rescue ActiveRecord::RecordNotUnique
        if connection.transaction_open?
          where(attributes).lock.find_by!(attributes)
        else
          find_by!(attributes)
        end
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L288" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-delete">
            
              delete(id_or_array)
            
          </h3>

          
            <div class="description">
              <p>Deletes the row with a primary key matching the <code>id</code> argument, using an SQL <code>DELETE</code> statement, and returns the number of rows deleted. Active Record objects are not instantiated, so the object’s callbacks are not executed, including any <code>:dependent</code> association options.</p>

<p>You can delete multiple rows at once by passing an <a href="../Array.html"><code>Array</code></a> of <code>id</code>s.</p>

<p>Note: Although it is often much faster than the alternative, <a href="Relation.html#method-i-destroy"><code>destroy</code></a>, skipping callbacks might bypass business logic in your application that ensures referential integrity or performs other essential jobs.</p>

<h4 id="method-i-delete-label-Examples">Examples</h4>

<pre><code># Delete a single row
Todo.delete(1)

# Delete multiple rows
Todo.delete([2,3,4])
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1057
    def delete(id_or_array)
      return 0 if id_or_array.nil? || (id_or_array.is_a?(Array) &amp;&amp; id_or_array.empty?)

      where(model.primary_key =&gt; id_or_array).delete_all
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1057" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-delete_all">
            
              delete_all()
            
          </h3>

          
            <div class="description">
              <p>Deletes the records without instantiating the records first, and hence not calling the <a href="Persistence.html#method-i-destroy">#destroy</a> method nor invoking callbacks. This is a single SQL DELETE statement that goes straight to the database, much more efficient than <a href="Relation.html#method-i-destroy_all"><code>destroy_all</code></a>. Be careful with relations though, in particular <code>:dependent</code> rules defined on associations are not honored. Returns the number of rows affected.</p>

<pre><code>Post.where(person_id: 5).where(category: [&#39;Something&#39;, &#39;Else&#39;]).delete_all
</code></pre>

<p>Both calls delete the affected posts all at once with a single DELETE statement. If you need to destroy dependent associations or call your <code>before_*</code> or <code>after_destroy</code> callbacks, use the <a href="Relation.html#method-i-destroy_all"><code>destroy_all</code></a> method instead.</p>

<p>If an invalid method is supplied, <a href="Relation.html#method-i-delete_all"><code>delete_all</code></a> raises an ActiveRecordError:</p>

<pre><code>Post.distinct.delete_all
# =&gt; ActiveRecord::ActiveRecordError: delete_all doesn&#39;t support distinct
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1011
    def delete_all
      return 0 if @none

      invalid_methods = INVALID_METHODS_FOR_DELETE_ALL.select do |method|
        value = @values[method]
        method == :distinct ? value : value&amp;.any?
      end
      if invalid_methods.any?
        raise ActiveRecordError.new(&quot;delete_all doesn&#39;t support #{invalid_methods.join(&#39;, &#39;)}&quot;)
      end

      model.with_connection do |c|
        arel = eager_loading? ? apply_join_dependency.arel : build_arel(c)
        arel.source.left = table

        group_values_arel_columns = arel_columns(group_values.uniq)
        having_clause_ast = having_clause.ast unless having_clause.empty?
        key = if model.composite_primary_key?
          primary_key.map { |pk| table[pk] }
        else
          table[primary_key]
        end
        stmt = arel.compile_delete(key, having_clause_ast, group_values_arel_columns)

        c.delete(stmt, &quot;#{model} Delete All&quot;).tap { reset }
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1011" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-delete_by">
            
              delete_by(*args)
            
          </h3>

          
            <div class="description">
              <p>Finds and deletes all records matching the specified conditions. This is short-hand for <code>relation.where(condition).delete_all</code>. Returns the number of rows affected.</p>

<p>If no record is found, returns <code>0</code> as zero rows were affected.</p>

<pre><code>Person.delete_by(id: 13)
Person.delete_by(name: &#39;Spartacus&#39;, rating: 4)
Person.delete_by(&quot;published_at &lt; ?&quot;, 2.weeks.ago)
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1119
    def delete_by(*args)
      where(*args).delete_all
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1119" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-destroy">
            
              destroy(id)
            
          </h3>

          
            <div class="description">
              <p>Destroy an object (or multiple objects) that has the given id. The object is instantiated first, therefore all callbacks and filters are fired off before the object is deleted. This method is less efficient than <a href="Relation.html#method-i-delete"><code>delete</code></a> but allows cleanup methods and other actions to be run.</p>

<p>This essentially finds the object (or multiple objects) with the given id, creates a new object from the attributes, and then calls destroy on it.</p>

<h4 id="method-i-destroy-label-Parameters">Parameters</h4>
<ul><li>
<p><code>id</code> - This should be the id or an array of ids to be destroyed.</p>
</li></ul>

<h4 id="method-i-destroy-label-Examples">Examples</h4>

<pre><code># Destroy a single object
Todo.destroy(1)

# Destroy multiple objects
todos = [1,2,3]
Todo.destroy(todos)
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1083
    def destroy(id)
      multiple_ids = if model.composite_primary_key?
        id.first.is_a?(Array)
      else
        id.is_a?(Array)
      end

      if multiple_ids
        find(id).each(&amp;:destroy)
      else
        find(id).destroy
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1083" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-destroy_all">
            
              destroy_all()
            
          </h3>

          
            <div class="description">
              <p>Destroys the records by instantiating each record and calling its <a href="Persistence.html#method-i-destroy">#destroy</a> method. Each object’s callbacks are executed (including <code>:dependent</code> association options). Returns the collection of objects that were destroyed; each will be frozen, to reflect that no changes should be made (since they can’t be persisted).</p>

<p>Note: Instantiation, callback execution, and deletion of each record can be time consuming when you’re removing many records at once. It generates at least one SQL <code>DELETE</code> query per record (or possibly more, to enforce your callbacks). If you want to delete many rows quickly, without concern for their associations or callbacks, use <a href="Relation.html#method-i-delete_all"><code>delete_all</code></a> instead.</p>

<h4 id="method-i-destroy_all-label-Examples">Examples</h4>

<pre><code>Person.where(age: 0..18).destroy_all
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 989
    def destroy_all
      records.each(&amp;:destroy).tap { reset }
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L989" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-destroy_by">
            
              destroy_by(*args)
            
          </h3>

          
            <div class="description">
              <p>Finds and destroys all records matching the specified conditions. This is short-hand for <code>relation.where(condition).destroy_all</code>. Returns the collection of objects that were destroyed.</p>

<p>If no record is found, returns empty array.</p>

<pre><code>Person.destroy_by(id: 13)
Person.destroy_by(name: &#39;Spartacus&#39;, rating: 4)
Person.destroy_by(&quot;published_at &lt; ?&quot;, 2.weeks.ago)
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1106
    def destroy_by(*args)
      where(*args).destroy_all
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1106" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-eager_loading-3F">
            
              eager_loading?()
            
          </h3>

          
            <div class="description">
              <p>Returns true if relation needs eager loading.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1238
    def eager_loading?
      @should_eager_load ||=
        eager_load_values.any? ||
        includes_values.any? &amp;&amp; (joined_includes_values.any? || references_eager_loaded_tables?)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1238" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-empty-3F">
            
              empty?()
            
          </h3>

          
            <div class="description">
              <p>Returns true if there are no records.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 362
    def empty?
      return true if @none

      if loaded?
        records.empty?
      else
        !exists?
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L362" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-encode_with">
            
              encode_with(coder)
            
          </h3>

          
            <div class="description">
              <p>Serializes the relation objects <a href="../Array.html"><code>Array</code></a>.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 348
    def encode_with(coder)
      coder.represent_seq(nil, records)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L348" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-explain">
            
              explain(*options)
            
          </h3>

          
            <div class="description">
              <p>Runs EXPLAIN on the query or queries triggered by this relation and returns the result as a string. The string is formatted imitating the ones printed by the database shell.</p>

<pre><code>User.all.explain
# EXPLAIN SELECT `users`.* FROM `users`
# ...
</code></pre>

<p>Note that this method actually runs the queries, since the results of some are needed by the next ones when eager loading is going on.</p>

<p>To run EXPLAIN on queries created by <code>first</code>, <code>pluck</code> and <code>count</code>, call these methods on <code>explain</code>:</p>

<pre><code>User.all.explain.count
# EXPLAIN SELECT COUNT(*) FROM `users`
# ...
</code></pre>

<p>The column name can be passed if required:</p>

<pre><code>User.all.explain.maximum(:id)
# EXPLAIN SELECT MAX(`users`.`id`) FROM `users`
# ...
</code></pre>

<p>Please see further details in the <a href="https://guides.rubyonrails.org/active_record_querying.html#running-explain">Active Record Query Interface guide</a>.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 332
    def explain(*options)
      ExplainProxy.new(self, options)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L332" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-find_or_create_by">
            
              find_or_create_by(attributes, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Finds the first record with the given attributes, or creates a record with the attributes if one is not found:</p>

<pre><code># Find the first user named &quot;Penélope&quot; or create a new one.
User.find_or_create_by(first_name: &#39;Penélope&#39;)
# =&gt; #&lt;User id: 1, first_name: &quot;Penélope&quot;, last_name: nil&gt;

# Find the first user named &quot;Penélope&quot; or create a new one.
# We already have one so the existing record will be returned.
User.find_or_create_by(first_name: &#39;Penélope&#39;)
# =&gt; #&lt;User id: 1, first_name: &quot;Penélope&quot;, last_name: nil&gt;

# Find the first user named &quot;Scarlett&quot; or create a new one with
# a particular last name.
User.create_with(last_name: &#39;Johansson&#39;).find_or_create_by(first_name: &#39;Scarlett&#39;)
# =&gt; #&lt;User id: 2, first_name: &quot;Scarlett&quot;, last_name: &quot;Johansson&quot;&gt;
</code></pre>

<p>This method accepts a block, which is passed down to <a href="Relation.html#method-i-create"><code>create</code></a>. The last example above can be alternatively written this way:</p>

<pre><code># Find the first user named &quot;Scarlett&quot; or create a new one with a
# particular last name.
User.find_or_create_by(first_name: &#39;Scarlett&#39;) do |user|
  user.last_name = &#39;Johansson&#39;
end
# =&gt; #&lt;User id: 2, first_name: &quot;Scarlett&quot;, last_name: &quot;Johansson&quot;&gt;
</code></pre>

<p>This method always returns a record, but if creation was attempted and failed due to validation errors it won’t be persisted, you get what <a href="Relation.html#method-i-create"><code>create</code></a> returns in such situation.</p>

<p>If creation failed because of a unique constraint, this method will assume it encountered a race condition and will try finding the record once more. If somehow the second find still does not find a record because a concurrent DELETE happened, it will then raise an <a href="RecordNotFound.html"><code>ActiveRecord::RecordNotFound</code></a> exception.</p>

<p>Please note <strong>this method is not atomic</strong>, it runs first a SELECT, and if there are no results an INSERT is attempted. So if the table doesn’t have a relevant unique constraint it could be the case that you end up with two or more similar records.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 231
    def find_or_create_by(attributes, &amp;block)
      find_by(attributes) || create_or_find_by(attributes, &amp;block)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L231" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-find_or_create_by-21">
            
              find_or_create_by!(attributes, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Like <a href="Relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a>, but calls <a href="Persistence/ClassMethods.html#method-i-create-21">create!</a> so an exception is raised if the created record is invalid.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 238
    def find_or_create_by!(attributes, &amp;block)
      find_by(attributes) || create_or_find_by!(attributes, &amp;block)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L238" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-find_or_initialize_by">
            
              find_or_initialize_by(attributes, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Like <a href="Relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a>, but calls new instead of <a href="Persistence/ClassMethods.html#method-i-create">create</a>.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 302
    def find_or_initialize_by(attributes, &amp;block)
      find_by(attributes) || new(attributes, &amp;block)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L302" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-initialize_copy">
            
              initialize_copy(other)
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 97
    def initialize_copy(other)
      @values = @values.dup
      reset
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L97" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-insert">
            
              insert(attributes, returning: nil, unique_by: nil, record_timestamps: nil)
            
          </h3>

          
            <div class="description">
              <p>Inserts a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>See <a href="Relation.html#method-i-insert_all"><code>insert_all</code></a> for documentation.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 644
    def insert(attributes, returning: nil, unique_by: nil, record_timestamps: nil)
      insert_all([ attributes ], returning: returning, unique_by: unique_by, record_timestamps: record_timestamps)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L644" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-insert-21">
            
              insert!(attributes, returning: nil, record_timestamps: nil)
            
          </h3>

          
            <div class="description">
              <p>Inserts a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>See <a href="Relation.html#method-i-insert_all-21"><code>insert_all!</code></a> for more.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 733
    def insert!(attributes, returning: nil, record_timestamps: nil)
      insert_all!([ attributes ], returning: returning, record_timestamps: record_timestamps)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L733" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-insert_all">
            
              insert_all(attributes, returning: nil, unique_by: nil, record_timestamps: nil)
            
          </h3>

          
            <div class="description">
              <p>Inserts multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>The <code>attributes</code> parameter is an <a href="../Array.html"><code>Array</code></a> of Hashes. Every <a href="../Hash.html"><code>Hash</code></a> determines the attributes for a single row and must have the same keys.</p>

<p>Rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped. Override with <code>:unique_by</code> (see below).</p>

<p>Returns an <a href="Result.html"><code>ActiveRecord::Result</code></a> with its contents based on <code>:returning</code> (see below).</p>

<h4 id="method-i-insert_all-label-Options">Options</h4>
<dl class="rdoc-list label-list"><dt>:returning
<dd>
<p>(PostgreSQL, SQLite3, and MariaDB only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Pass <code>returning: %w[ id name ]</code> for both id and name or <code>returning: false</code> to omit the underlying <code>RETURNING</code> SQL clause entirely.</p>

<p>You can also pass an SQL string if you need more control on the return values (for example, <code>returning: Arel.sql(&quot;id, name as new_name&quot;)</code>).</p>
</dd><dt>:unique_by
<dd>
<p>(PostgreSQL and SQLite only) By default rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped.</p>

<p>To skip rows according to just one unique index pass <code>:unique_by</code>.</p>

<p>Consider a Book model where no duplicate ISBNs make sense, but if any row has an existing id, or is not unique by another unique index, <a href="RecordNotUnique.html"><code>ActiveRecord::RecordNotUnique</code></a> is raised.</p>

<p>Unique indexes can be identified by columns or name:</p>

<pre><code>unique_by: :isbn
unique_by: %i[ author_id name ]
unique_by: :index_books_on_isbn
</code></pre>
</dd><dt>:record_timestamps
<dd>
<p>By default, automatic setting of timestamp columns is controlled by the model’s <code>record_timestamps</code> config, matching typical behavior.</p>

<p>To override this and force automatic setting of timestamp columns one way or the other, pass <code>:record_timestamps</code>:</p>

<pre><code>record_timestamps: true  # Always set timestamps automatically
record_timestamps: false # Never set timestamps automatically
</code></pre>
</dd></dl>

<p>Because it relies on the index information from the database <code>:unique_by</code> is recommended to be paired with Active Record’s schema_cache.</p>

<h4 id="method-i-insert_all-label-Example">Example</h4>

<pre><code># Insert records and skip inserting any duplicates.
# Here &quot;Eloquent Ruby&quot; is skipped because its id is not unique.

Book.insert_all([
  { id: 1, title: &quot;Rework&quot;, author: &quot;David&quot; },
  { id: 1, title: &quot;Eloquent Ruby&quot;, author: &quot;Russ&quot; }
])

# insert_all works on chained scopes, and you can use create_with
# to set default attributes for all inserted records.

author.books.create_with(created_at: Time.now).insert_all([
  { id: 1, title: &quot;Rework&quot; },
  { id: 2, title: &quot;Eloquent Ruby&quot; }
])
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 723
    def insert_all(attributes, returning: nil, unique_by: nil, record_timestamps: nil)
      InsertAll.execute(self, attributes, on_duplicate: :skip, returning: returning, unique_by: unique_by, record_timestamps: record_timestamps)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L723" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-insert_all-21">
            
              insert_all!(attributes, returning: nil, record_timestamps: nil)
            
          </h3>

          
            <div class="description">
              <p>Inserts multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>The <code>attributes</code> parameter is an <a href="../Array.html"><code>Array</code></a> of Hashes. Every <a href="../Hash.html"><code>Hash</code></a> determines the attributes for a single row and must have the same keys.</p>

<p>Raises <a href="RecordNotUnique.html"><code>ActiveRecord::RecordNotUnique</code></a> if any rows violate a unique index on the table. In that case, no rows are inserted.</p>

<p>To skip duplicate rows, see <a href="Relation.html#method-i-insert_all"><code>insert_all</code></a>. To replace them, see <a href="Relation.html#method-i-upsert_all"><code>upsert_all</code></a>.</p>

<p>Returns an <a href="Result.html"><code>ActiveRecord::Result</code></a> with its contents based on <code>:returning</code> (see below).</p>

<h4 id="method-i-insert_all-21-label-Options">Options</h4>
<dl class="rdoc-list label-list"><dt>:returning
<dd>
<p>(PostgreSQL, SQLite3, and MariaDB only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Pass <code>returning: %w[ id name ]</code> for both id and name or <code>returning: false</code> to omit the underlying <code>RETURNING</code> SQL clause entirely.</p>

<p>You can also pass an SQL string if you need more control on the return values (for example, <code>returning: Arel.sql(&quot;id, name as new_name&quot;)</code>).</p>
</dd><dt>:record_timestamps
<dd>
<p>By default, automatic setting of timestamp columns is controlled by the model’s <code>record_timestamps</code> config, matching typical behavior.</p>

<p>To override this and force automatic setting of timestamp columns one way or the other, pass <code>:record_timestamps</code>:</p>

<pre><code>record_timestamps: true  # Always set timestamps automatically
record_timestamps: false # Never set timestamps automatically
</code></pre>
</dd></dl>

<h4 id="method-i-insert_all-21-label-Examples">Examples</h4>

<pre><code># Insert multiple records
Book.insert_all!([
  { title: &quot;Rework&quot;, author: &quot;David&quot; },
  { title: &quot;Eloquent Ruby&quot;, author: &quot;Russ&quot; }
])

# Raises ActiveRecord::RecordNotUnique because &quot;Eloquent Ruby&quot;
# does not have a unique id.
Book.insert_all!([
  { id: 1, title: &quot;Rework&quot;, author: &quot;David&quot; },
  { id: 1, title: &quot;Eloquent Ruby&quot;, author: &quot;Russ&quot; }
])
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 790
    def insert_all!(attributes, returning: nil, record_timestamps: nil)
      InsertAll.execute(self, attributes, on_duplicate: :raise, returning: returning, record_timestamps: record_timestamps)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L790" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-inspect">
            
              inspect()
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1290
    def inspect
      subject = loaded? ? records : annotate(&quot;loading for inspect&quot;)
      entries = subject.take([limit_value, 11].compact.min).map!(&amp;:inspect)

      entries[10] = &quot;...&quot; if entries.size == 11

      &quot;#&lt;#{self.class.name} [#{entries.join(&#39;, &#39;)}]&gt;&quot;
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1290" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-joined_includes_values">
            
              joined_includes_values()
            
          </h3>

          
            <div class="description">
              <p>Joins that are also marked for preloading. In which case we should just eager load them. Note that this is a naive implementation because we could have strings and symbols which represent the same association, but that aren’t matched by this. Also, we could have nested hashes which partially match, e.g. <code>{ a: :b } &amp; { a: [:b, :c] }</code></p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1248
    def joined_includes_values
      includes_values &amp; joins_values
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1248" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-load">
            
              load(&amp;block)
            
          </h3>

          
            <div class="description">
              <p>Causes the records to be loaded from the database if they have not been loaded already. You can use this if for some reason you need to explicitly load some records before actually using them. The return value is the relation itself, not the records.</p>

<pre><code>Post.where(published: true).load # =&gt; #&lt;ActiveRecord::Relation&gt;
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1179
    def load(&amp;block)
      if !loaded? || scheduled?
        @records = exec_queries(&amp;block)
        @loaded = true
      end

      self
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1179" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-load_async">
            
              load_async()
            
          </h3>

          
            <div class="description">
              <p>Schedule the query to be performed from a background thread pool.</p>

<pre><code>Post.where(published: true).load_async # =&gt; #&lt;ActiveRecord::Relation&gt;
</code></pre>

<p>When the <code>Relation</code> is iterated, if the background query wasn’t executed yet, it will be performed by the foreground thread.</p>

<p>Note that <a href="https://guides.rubyonrails.org/configuring.html#config-active-record-async-query-executor">config.active_record.async_query_executor</a> must be configured for queries to actually be executed concurrently. Otherwise it defaults to executing them in the foreground.</p>

<p>If the query was actually executed in the background, the Active Record logs will show it by prefixing the log line with <code>ASYNC</code>:</p>

<pre><code>ASYNC Post Load (0.0ms) (db time 2ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; LIMIT 100
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1138
    def load_async
      with_connection do |c|
        return load if !c.async_enabled?

        unless loaded?
          result = exec_main_query(async: !c.current_transaction.joinable?)

          if result.is_a?(Array)
            @records = result
          else
            @future_result = result
          end
          @loaded = true
        end
      end

      self
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1138" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-many-3F">
            
              many?()
            
          </h3>

          
            <div class="description">
              <p>Returns true if there is more than one record.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 413
    def many?
      return false if @none

      return super if block_given?
      return records.many? if loaded?
      limited_count &gt; 1
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L413" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-new">
            
              new(attributes = nil, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Initializes new record from relation while maintaining the current scope.</p>

<p>Expects arguments in the same format as <a href="Core.html#method-c-new">ActiveRecord::Base.new</a>.</p>

<pre><code>users = User.where(name: &#39;DHH&#39;)
user = users.new # =&gt; #&lt;User id: nil, name: &quot;DHH&quot;, created_at: nil, updated_at: nil&gt;
</code></pre>

<p>You can also pass a block to new with the new record as argument:</p>

<pre><code>user = users.new { |user| user.name = &#39;Oscar&#39; }
user.name # =&gt; Oscar
</code></pre>
            </div>
          

          
            <div class="aka">
              Also aliased as: <a href="Relation.html#method-i-build">build</a>
            </div>
          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 125
    def new(attributes = nil, &amp;block)
      if attributes.is_a?(Array)
        attributes.collect { |attr| new(attr, &amp;block) }
      else
        block = current_scope_restoring_block(&amp;block)
        scoping { _new(attributes, &amp;block) }
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L125" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-none-3F">
            
              none?(*args)
            
          </h3>

          
            <div class="description">
              <p>Returns true if there are no records.</p>

<p>When a pattern argument is given, this method checks whether elements in the <a href="../Enumerable.html"><code>Enumerable</code></a> match the pattern via the case-equality operator (<code>===</code>).</p>

<pre><code>posts.none?(Comment) # =&gt; true or false
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 378
    def none?(*args)
      return true if @none

      return super if args.present? || block_given?
      empty?
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L378" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-one-3F">
            
              one?(*args)
            
          </h3>

          
            <div class="description">
              <p>Returns true if there is exactly one record.</p>

<p>When a pattern argument is given, this method checks whether elements in the <a href="../Enumerable.html"><code>Enumerable</code></a> match the pattern via the case-equality operator (<code>===</code>).</p>

<pre><code>posts.one?(Post) # =&gt; true or false
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 404
    def one?(*args)
      return false if @none

      return super if args.present? || block_given?
      return records.one? if loaded?
      limited_count == 1
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L404" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-pretty_print">
            
              pretty_print(pp)
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1264
    def pretty_print(pp)
      subject = loaded? ? records : annotate(&quot;loading for pp&quot;)
      entries = subject.take([limit_value, 11].compact.min)

      entries[10] = &quot;...&quot; if entries.size == 11

      pp.pp(entries)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1264" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-readonly-3F">
            
              readonly?()
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1278
    def readonly?
      readonly_value
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1278" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-reload">
            
              reload()
            
          </h3>

          
            <div class="description">
              <p>Forces reloading of relation.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1189
    def reload
      reset
      load
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1189" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-reset">
            
              reset()
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1194
    def reset
      @future_result&amp;.cancel
      @future_result = nil
      @delegate_to_model = false
      @to_sql = @arel = @loaded = @should_eager_load = nil
      @offsets = @take = nil
      @cache_keys = nil
      @cache_versions = nil
      @records = nil
      self
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1194" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-scheduled-3F">
            
              scheduled?()
            
          </h3>

          
            <div class="description">
              <p>Returns <code>true</code> if the relation was scheduled on the background thread pool.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1169
    def scheduled?
      !!@future_result
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1169" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-scope_for_create">
            
              scope_for_create()
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1231
    def scope_for_create
      hash = where_clause.to_h(model.table_name, equality_only: true)
      create_with_value.each { |k, v| hash[k.to_s] = v } unless create_with_value.empty?
      hash
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1231" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-scoping">
            
              scoping(all_queries: nil, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Scope all queries to the current scope.</p>

<pre><code>Comment.where(post_id: 1).scoping do
  Comment.first
end
# SELECT &quot;comments&quot;.* FROM &quot;comments&quot; WHERE &quot;comments&quot;.&quot;post_id&quot; = 1 ORDER BY &quot;comments&quot;.&quot;id&quot; ASC LIMIT 1
</code></pre>

<p>If <code>all_queries: true</code> is passed, scoping will apply to all queries for the relation including <code>update</code> and <code>delete</code> on instances. Once <code>all_queries</code> is set to true it cannot be set to false in a nested block.</p>

<p>Please check unscoped if you want to remove all previous scopes (including the default_scope) during the execution of a block.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 541
    def scoping(all_queries: nil, &amp;block)
      registry = model.scope_registry
      if global_scope?(registry) &amp;&amp; all_queries == false
        raise ArgumentError, &quot;Scoping is set to apply to all queries and cannot be unset in a nested block.&quot;
      elsif already_in_scope?(registry)
        yield
      else
        _scoping(self, registry, all_queries, &amp;block)
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L541" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-size">
            
              size()
            
          </h3>

          
            <div class="description">
              <p>Returns size of the records.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 353
    def size
      if loaded?
        records.length
      else
        count(:all)
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L353" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-to_a">
            
              to_a()
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          
            <div class="aka">
              Alias for: <a href="Relation.html#method-i-to_ary">to_ary</a>
            </div>
          

          
          
        </div>
        
        <div class="method">
          <h3 id="method-i-to_ary">
            
              to_ary()
            
          </h3>

          
            <div class="description">
              <p>Converts relation objects to <a href="../Array.html"><code>Array</code></a>.</p>
            </div>
          

          
            <div class="aka">
              Also aliased as: <a href="Relation.html#method-i-to_a">to_a</a>
            </div>
          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 337
    def to_ary
      records.dup
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L337" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-to_sql">
            
              to_sql()
            
          </h3>

          
            <div class="description">
              <p>Returns sql statement for the relation.</p>

<pre><code>User.where(name: &#39;Oscar&#39;).to_sql
# SELECT &quot;users&quot;.* FROM &quot;users&quot;  WHERE &quot;users&quot;.&quot;name&quot; = &#39;Oscar&#39;
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1210
    def to_sql
      @to_sql ||= if eager_loading?
        apply_join_dependency do |relation, join_dependency|
          relation = join_dependency.apply_column_aliases(relation)
          relation.to_sql
        end
      else
        model.with_connection do |conn|
          conn.unprepared_statement { conn.to_sql(arel) }
        end
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1210" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-touch_all">
            
              touch_all(*names, time: nil)
            
          </h3>

          
            <div class="description">
              <p>Touches all records in the current relation, setting the <code>updated_at</code>/<code>updated_on</code> attributes to the current time or the time specified. It does not instantiate the involved models, and it does not trigger Active Record callbacks or validations. This method can be passed attribute names and an optional time argument. If attribute names are passed, they are updated along with <code>updated_at</code>/<code>updated_on</code> attributes. If no time argument is passed, the current time is used as default.</p>

<h3 id="method-i-touch_all-label-Examples">Examples</h3>

<pre><code># Touch all records
Person.all.touch_all
# =&gt; &quot;UPDATE \&quot;people\&quot; SET \&quot;updated_at\&quot; = &#39;2018-01-04 22:55:23.132670&#39;&quot;

# Touch multiple records with a custom attribute
Person.all.touch_all(:created_at)
# =&gt; &quot;UPDATE \&quot;people\&quot; SET \&quot;updated_at\&quot; = &#39;2018-01-04 22:55:23.132670&#39;, \&quot;created_at\&quot; = &#39;2018-01-04 22:55:23.132670&#39;&quot;

# Touch multiple records with a specified time
Person.all.touch_all(time: Time.new(2020, 5, 16, 0, 0, 0))
# =&gt; &quot;UPDATE \&quot;people\&quot; SET \&quot;updated_at\&quot; = &#39;2020-05-16 00:00:00&#39;&quot;

# Touch records with scope
Person.where(name: &#39;David&#39;).touch_all
# =&gt; &quot;UPDATE \&quot;people\&quot; SET \&quot;updated_at\&quot; = &#39;2018-01-04 22:55:23.132670&#39; WHERE \&quot;people\&quot;.\&quot;name\&quot; = &#39;David&#39;&quot;
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 969
    def touch_all(*names, time: nil)
      update_all model.touch_attributes_with_time(*names, time: time)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L969" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-update_all">
            
              update_all(updates)
            
          </h3>

          
            <div class="description">
              <p>Updates all records in the current relation with details given. This method constructs a single SQL UPDATE statement and sends it straight to the database. It does not instantiate the involved models and it does not trigger Active Record callbacks or validations. However, values passed to <a href="Relation.html#method-i-update_all"><code>update_all</code></a> will still go through Active Record’s normal type casting and serialization. Returns the number of rows affected.</p>

<p>Note: As Active Record callbacks are not triggered, this method will not automatically update <code>updated_at</code>/<code>updated_on</code> columns.</p>

<h4 id="method-i-update_all-label-Parameters">Parameters</h4>
<ul><li>
<p><code>updates</code> - A string, array, or hash representing the SET part of an SQL statement. Any strings provided will be type cast, unless you use <code>Arel.sql</code>. (Don’t pass user-provided values to <code>Arel.sql</code>.)</p>
</li></ul>

<h4 id="method-i-update_all-label-Examples">Examples</h4>

<pre><code># Update all customers with the given attributes
Customer.update_all wants_email: true

# Update all books with &#39;Rails&#39; in their title
Book.where(&#39;title LIKE ?&#39;, &#39;%Rails%&#39;).update_all(author: &#39;David&#39;)

# Update all books that match conditions, but limit it to 5 ordered by date
Book.where(&#39;title LIKE ?&#39;, &#39;%Rails%&#39;).order(:created_at).limit(5).update_all(author: &#39;David&#39;)

# Update all invoices and set the number column to its id value.
Invoice.update_all(&#39;number = id&#39;)

# Update all books with &#39;Rails&#39; in their title
Book.where(&#39;title LIKE ?&#39;, &#39;%Rails%&#39;).update_all(title: Arel.sql(&quot;title + &#39; - volume 1&#39;&quot;))
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 588
    def update_all(updates)
      raise ArgumentError, &quot;Empty list of attributes to change&quot; if updates.blank?

      return 0 if @none

      if updates.is_a?(Hash)
        if model.locking_enabled? &amp;&amp;
            !updates.key?(model.locking_column) &amp;&amp;
            !updates.key?(model.locking_column.to_sym)
          attr = table[model.locking_column]
          updates[attr.name] = _increment_attribute(attr)
        end
        values = _substitute_values(updates)
      else
        values = Arel.sql(model.sanitize_sql_for_assignment(updates, table.name))
      end

      model.with_connection do |c|
        arel = eager_loading? ? apply_join_dependency.arel : build_arel(c)
        arel.source.left = table

        group_values_arel_columns = arel_columns(group_values.uniq)
        having_clause_ast = having_clause.ast unless having_clause.empty?
        key = if model.composite_primary_key?
          primary_key.map { |pk| table[pk] }
        else
          table[primary_key]
        end
        stmt = arel.compile_update(values, key, having_clause_ast, group_values_arel_columns)
        c.update(stmt, &quot;#{model} Update All&quot;).tap { reset }
      end
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L588" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-update_counters">
            
              update_counters(counters)
            
          </h3>

          
            <div class="description">
              <p>Updates the counters of the records in the current relation.</p>

<h4 id="method-i-update_counters-label-Parameters">Parameters</h4>
<ul><li>
<p><code>counter</code> - A <a href="../Hash.html"><code>Hash</code></a> containing the names of the fields to update as keys and the amount to update as values.</p>
</li><li>
<p><code>:touch</code> option - Touch the timestamp columns when updating.</p>
</li><li>
<p>If attributes names are passed, they are updated along with update_at/on attributes.</p>
</li></ul>

<h4 id="method-i-update_counters-label-Examples">Examples</h4>

<pre><code># For Posts by a given author increment the comment_count by 1.
Post.where(author_id: author.id).update_counters(comment_count: 1)
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 926
    def update_counters(counters)
      touch = counters.delete(:touch)

      updates = {}
      counters.each do |counter_name, value|
        attr = table[counter_name]
        updates[attr.name] = _increment_attribute(attr, value)
      end

      if touch
        names = touch if touch != true
        names = Array.wrap(names)
        options = names.extract_options!
        touch_updates = model.touch_attributes_with_time(*names, **options)
        updates.merge!(touch_updates) unless touch_updates.empty?
      end

      update_all updates
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L926" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-upsert">
            
              upsert(attributes, **kwargs)
            
          </h3>

          
            <div class="description">
              <p>Updates or inserts (upserts) a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>See <a href="Relation.html#method-i-upsert_all"><code>upsert_all</code></a> for documentation.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 800
    def upsert(attributes, **kwargs)
      upsert_all([ attributes ], **kwargs)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L800" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-upsert_all">
            
              upsert_all(attributes, on_duplicate: :update, update_only: nil, returning: nil, unique_by: nil, record_timestamps: nil)
            
          </h3>

          
            <div class="description">
              <p>Updates or inserts (upserts) multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record’s type casting and serialization.</p>

<p>The <code>attributes</code> parameter is an <a href="../Array.html"><code>Array</code></a> of Hashes. Every <a href="../Hash.html"><code>Hash</code></a> determines the attributes for a single row and must have the same keys.</p>

<p>Returns an <a href="Result.html"><code>ActiveRecord::Result</code></a> with its contents based on <code>:returning</code> (see below).</p>

<p>By default, <code>upsert_all</code> will update all the columns that can be updated when there is a conflict. These are all the columns except primary keys, read-only columns, and columns covered by the optional <code>unique_by</code>.</p>

<h4 id="method-i-upsert_all-label-Options">Options</h4>
<dl class="rdoc-list label-list"><dt>:returning
<dd>
<p>(PostgreSQL, SQLite3, and MariaDB only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Pass <code>returning: %w[ id name ]</code> for both id and name or <code>returning: false</code> to omit the underlying <code>RETURNING</code> SQL clause entirely.</p>

<p>You can also pass an SQL string if you need more control on the return values (for example, <code>returning: Arel.sql(&quot;id, name as new_name&quot;)</code>).</p>
</dd><dt>:unique_by
<dd>
<p>(PostgreSQL and SQLite only) By default rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped.</p>

<p>To skip rows according to just one unique index pass <code>:unique_by</code>.</p>

<p>Consider a Book model where no duplicate ISBNs make sense, but if any row has an existing id, or is not unique by another unique index, <a href="RecordNotUnique.html"><code>ActiveRecord::RecordNotUnique</code></a> is raised.</p>

<p>Unique indexes can be identified by columns or name:</p>

<pre><code>unique_by: :isbn
unique_by: %i[ author_id name ]
unique_by: :index_books_on_isbn
</code></pre>
</dd></dl>

<p>Because it relies on the index information from the database <code>:unique_by</code> is recommended to be paired with Active Record’s schema_cache.</p>
<dl class="rdoc-list label-list"><dt>:on_duplicate
<dd>
<p>Configure the SQL update sentence that will be used in case of conflict.</p>

<p>NOTE: If you use this option you must provide all the columns you want to update by yourself.</p>

<p>Example:</p>

<pre><code>Commodity.upsert_all(
  [
    { id: 2, name: &quot;Copper&quot;, price: 4.84 },
    { id: 4, name: &quot;Gold&quot;, price: 1380.87 },
    { id: 6, name: &quot;Aluminium&quot;, price: 0.35 }
  ],
  on_duplicate: Arel.sql(&quot;price = GREATEST(commodities.price, EXCLUDED.price)&quot;)
)
</code></pre>

<p>See the related <code>:update_only</code> option. Both options can’t be used at the same time.</p>
</dd><dt>:update_only
<dd>
<p>Provide a list of column names that will be updated in case of conflict. If not provided, <code>upsert_all</code> will update all the columns that can be updated. These are all the columns except primary keys, read-only columns, and columns covered by the optional <code>unique_by</code></p>

<p>Example:</p>

<pre><code>Commodity.upsert_all(
  [
    { id: 2, name: &quot;Copper&quot;, price: 4.84 },
    { id: 4, name: &quot;Gold&quot;, price: 1380.87 },
    { id: 6, name: &quot;Aluminium&quot;, price: 0.35 }
  ],
  update_only: [:price] # Only prices will be updated
)
</code></pre>

<p>See the related <code>:on_duplicate</code> option. Both options can’t be used at the same time.</p>
</dd><dt>:record_timestamps
<dd>
<p>By default, automatic setting of timestamp columns is controlled by the model’s <code>record_timestamps</code> config, matching typical behavior.</p>

<p>To override this and force automatic setting of timestamp columns one way or the other, pass <code>:record_timestamps</code>:</p>

<pre><code>record_timestamps: true  # Always set timestamps automatically
record_timestamps: false # Never set timestamps automatically
</code></pre>
</dd></dl>

<h4 id="method-i-upsert_all-label-Examples">Examples</h4>

<pre><code># Inserts multiple records, performing an upsert when records have duplicate ISBNs.
# Here &quot;Eloquent Ruby&quot; overwrites &quot;Rework&quot; because its ISBN is duplicate.

Book.upsert_all([
  { title: &quot;Rework&quot;, author: &quot;David&quot;, isbn: &quot;1&quot; },
  { title: &quot;Eloquent Ruby&quot;, author: &quot;Russ&quot;, isbn: &quot;1&quot; }
], unique_by: :isbn)

Book.find_by(isbn: &quot;1&quot;).title # =&gt; &quot;Eloquent Ruby&quot;
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 910
    def upsert_all(attributes, on_duplicate: :update, update_only: nil, returning: nil, unique_by: nil, record_timestamps: nil)
      InsertAll.execute(self, attributes, on_duplicate: on_duplicate, update_only: update_only, returning: returning, unique_by: unique_by, record_timestamps: record_timestamps)
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L910" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-values">
            
              values()
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1282
    def values
      @values.dup
    end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1282" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
      
      <h2 id="instance-protected-methods">Instance Protected methods</h2>
      
        <div class="method">
          <h3 id="method-i-load_records">
            
              load_records(records)
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/relation.rb, line 1331
      def load_records(records)
        @records = records.freeze
        @loaded = true
      end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/dd8f7185faeca6ee968a6e9367f6d8601a83b8db/activerecord/lib/active_record/relation.rb#L1331" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
      
    
  
</div>

    </div>
</div>
