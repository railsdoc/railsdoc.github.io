---
title: ActiveRecord::ConnectionAdapters::ConnectionPool
layout: default
---
<div class="main">
    <div class="banner">
        
            <span>Ruby on Rails 8.1.0.rc1</span><br />
        
        <div class="type">Class</div>
        <h1>
            ActiveRecord::ConnectionAdapters::ConnectionPool
            
                <span class="parent">&lt;
                    
                    <a href="../../Object.html">Object</a>
                    
                </span>
            
        </h1>
        <ul class="files">
            
            <li><a href="../../../files/activerecord/lib/active_record/connection_adapters/abstract/connection_pool_rb.html">activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb</a></li>
            
            <li><a href="../../../files/activerecord/lib/active_record/connection_adapters/abstract/connection_pool/queue_rb.html">activerecord/lib/active_record/connection_adapters/abstract/connection_pool/queue.rb</a></li>
            
            <li><a href="../../../files/activerecord/lib/active_record/connection_adapters/abstract/connection_pool/reaper_rb.html">activerecord/lib/active_record/connection_adapters/abstract/connection_pool/reaper.rb</a></li>
            
            <li><a href="../../../files/activerecord/lib/active_record/connection_adapters/abstract/query_cache_rb.html">activerecord/lib/active_record/connection_adapters/abstract/query_cache.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="class-ActiveRecord::ConnectionAdapters::ConnectionPool-label-Active+Record+Connection+Pool">Active Record Connection Pool</h1>

<p>Connection pool base class for managing Active Record database connections.</p>

<h2 id="class-ActiveRecord::ConnectionAdapters::ConnectionPool-label-Introduction">Introduction</h2>

<p>A connection pool synchronizes thread access to a limited number of database connections. The basic idea is that each thread checks out a database connection from the pool, uses that connection, and checks the connection back in. <a href="ConnectionPool.html"><code>ConnectionPool</code></a> is completely thread-safe, and will ensure that a connection cannot be used by two threads at the same time, as long as ConnectionPool’s contract is correctly followed. It will also handle cases in which there are more threads than connections: if all connections have been checked out, and a thread tries to checkout a connection anyway, then <a href="ConnectionPool.html"><code>ConnectionPool</code></a> will wait until some other thread has checked in a connection, or the <a href="ConnectionPool.html#attribute-i-checkout_timeout"><code>checkout_timeout</code></a> has expired.</p>

<h2 id="class-ActiveRecord::ConnectionAdapters::ConnectionPool-label-Obtaining+-28checking+out-29+a+connection">Obtaining (checking out) a connection</h2>

<p>Connections can be obtained and used from a connection pool in several ways:</p>
<ol><li>
<p>Simply use <a href="../ConnectionHandling.html#method-i-lease_connection">ActiveRecord::Base.lease_connection</a>. When you’re done with the connection(s) and wish it to be returned to the pool, you call <a href="ConnectionHandler.html#method-i-clear_active_connections-21">ActiveRecord::Base.connection_handler.clear_active_connections!</a>. This is the default behavior for Active Record when used in conjunction with Action Pack’s request handling cycle.</p>
</li><li>
<p>Manually check out a connection from the pool with <a href="ConnectionPool.html#method-i-checkout">ActiveRecord::Base.connection_pool.checkout</a>. You are responsible for returning this connection to the pool when finished by calling <a href="ConnectionPool.html#method-i-checkin">ActiveRecord::Base.connection_pool.checkin(connection)</a>.</p>
</li><li>
<p>Use <a href="ConnectionPool.html#method-i-with_connection">ActiveRecord::Base.connection_pool.with_connection(&amp;block)</a>, which obtains a connection, yields it as the sole argument to the block, and returns it to the pool after the block completes.</p>
</li></ol>

<p>Connections in the pool are actually <a href="AbstractAdapter.html"><code>AbstractAdapter</code></a> objects (or objects compatible with AbstractAdapter’s interface).</p>

<p>While a thread has a connection checked out from the pool using one of the above three methods, that connection will automatically be the one used by <a href="../../ActiveRecord.html"><code>ActiveRecord</code></a> queries executing on that thread. It is not required to explicitly pass the checked out connection to Rails models or queries, for example.</p>

<h2 id="class-ActiveRecord::ConnectionAdapters::ConnectionPool-label-Options">Options</h2>

<p>There are several connection-pooling-related options that you can add to your database connection configuration:</p>
<ul><li>
<p><a href="ConnectionPool.html#attribute-i-checkout_timeout"><code>checkout_timeout</code></a>: number of seconds to wait for a connection to become available before giving up and raising a timeout error (default 5 seconds).</p>
</li><li>
<p><code>idle_timeout</code>: number of seconds that a connection will be kept unused in the pool before it is automatically disconnected (default 300 seconds). Set this to zero to keep connections forever.</p>
</li><li>
<p><code>keepalive</code>: number of seconds between keepalive checks if the connection has been idle (default 600 seconds).</p>
</li><li>
<p><a href="ConnectionPool.html#attribute-i-max_age"><code>max_age</code></a>: number of seconds the pool will allow the connection to exist before retiring it at next checkin. (default Float::INFINITY).</p>
</li><li>
<p><a href="ConnectionPool.html#attribute-i-max_connections"><code>max_connections</code></a>: maximum number of connections the pool may manage (default 5). Set to <code>nil</code> or -1 for unlimited connections.</p>
</li><li>
<p><a href="ConnectionPool.html#attribute-i-min_connections"><code>min_connections</code></a>: minimum number of connections the pool will open and maintain (default 0).</p>
</li><li>
<p><code>pool_jitter</code>: maximum reduction factor to apply to <a href="ConnectionPool.html#attribute-i-max_age"><code>max_age</code></a> and <code>keepalive</code> intervals (default 0.2; range 0.0-1.0).</p>
</li></ul>

    </div>
  

  

  
  


  
    <h2 id="namespace">Namespace</h2>

    

    
      <h3 id="class">Class</h3>
      <ul>
      
        <li><a href="ConnectionPool/Queue.html">ActiveRecord::ConnectionAdapters::ConnectionPool::Queue</a></li>
      
        <li><a href="ConnectionPool/Reaper.html">ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper</a></li>
      
      </ul>
    
  

  
    <h2 id="methods">Methods</h2>
    <ul>
      
        <li>
          <a href="#method-i-activate">activate</a>
        </li>
      
        <li>
          <a href="#method-i-activated-3F">activated?</a>
        </li>
      
        <li>
          <a href="#method-i-active_connection-3F">active_connection?</a>
        </li>
      
        <li>
          <a href="#method-i-checkin">checkin</a>
        </li>
      
        <li>
          <a href="#method-i-checkout">checkout</a>
        </li>
      
        <li>
          <a href="#method-i-clear_reloadable_connections">clear_reloadable_connections</a>
        </li>
      
        <li>
          <a href="#method-i-clear_reloadable_connections-21">clear_reloadable_connections!</a>
        </li>
      
        <li>
          <a href="#method-i-connected-3F">connected?</a>
        </li>
      
        <li>
          <a href="#method-i-connections">connections</a>
        </li>
      
        <li>
          <a href="#method-i-disconnect">disconnect</a>
        </li>
      
        <li>
          <a href="#method-i-disconnect-21">disconnect!</a>
        </li>
      
        <li>
          <a href="#method-i-flush">flush</a>
        </li>
      
        <li>
          <a href="#method-i-flush-21">flush!</a>
        </li>
      
        <li>
          <a href="#method-c-install_executor_hooks">install_executor_hooks</a>
        </li>
      
        <li>
          <a href="#method-i-keep_alive">keep_alive</a>
        </li>
      
        <li>
          <a href="#method-i-lease_connection">lease_connection</a>
        </li>
      
        <li>
          <a href="#method-c-new">new</a>
        </li>
      
        <li>
          <a href="#method-i-pool_transaction_isolation_level">pool_transaction_isolation_level</a>
        </li>
      
        <li>
          <a href="#method-i-pool_transaction_isolation_level-3D">pool_transaction_isolation_level=</a>
        </li>
      
        <li>
          <a href="#method-i-preconnect">preconnect</a>
        </li>
      
        <li>
          <a href="#method-i-prepopulate">prepopulate</a>
        </li>
      
        <li>
          <a href="#method-i-reap">reap</a>
        </li>
      
        <li>
          <a href="#method-i-recycle-21">recycle!</a>
        </li>
      
        <li>
          <a href="#method-i-release_connection">release_connection</a>
        </li>
      
        <li>
          <a href="#method-i-remove">remove</a>
        </li>
      
        <li>
          <a href="#method-i-retire_old_connections">retire_old_connections</a>
        </li>
      
        <li>
          <a href="#method-i-schema_cache">schema_cache</a>
        </li>
      
        <li>
          <a href="#method-i-schema_reflection-3D">schema_reflection=</a>
        </li>
      
        <li>
          <a href="#method-i-stat">stat</a>
        </li>
      
        <li>
          <a href="#method-i-with_connection">with_connection</a>
        </li>
      
    </ul>
  

  
    <!-- Includes -->
    <h2 id="included-modules">Included Modules</h2>
    <ul>
      
        <li>
          
            MonitorMixin
          
        </li>
      
    </ul>
  

  
    

    

    
      <!-- Section constants -->
      <h2 id="constants">Constants</h2>
      <table border='0' cellpadding='5'>
        
          <tr valign='top'>
            <td class="attr-name">WeakThreadKeyMap</td>
            <td>=</td>
            <td class="attr-value">ObjectSpace::WeakKeyMap</td>
          </tr>
          
        
      </table>
    

    
      <!-- Section attributes -->
      <h2 id="attributes">Attributes</h2>
      <table border='0' cellpadding='5'>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>async_executor</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [RW]
            </td>
            <td class='attr-name'>automatic_reconnect</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [RW]
            </td>
            <td class='attr-name'>checkout_timeout</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>db_config</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>keepalive</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>max_age</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>max_connections</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>min_connections</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>pool_config</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>reaper</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>role</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>shard</td>
            <td class='attr-desc'></td>
          </tr>
        
          <tr valign='top'>
            <td class='attr-rw'>
              [R]
            </td>
            <td class='attr-name'>size</td>
            <td class='attr-desc'></td>
          </tr>
        
      </table>
    

    <!-- Methods -->
    
      <h2 id="class-public-methods">Class Public methods</h2>
      
        <div class="method">
          <h3 id="method-c-install_executor_hooks">
            
              install_executor_hooks(executor = ActiveSupport::Executor)
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 231
def install_executor_hooks(executor = ActiveSupport::Executor)
  executor.register_hook(ExecutorHooks)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L231" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-c-new">
            
              new(pool_config)
            
          </h3>

          
            <div class="description">
              <p>Creates a new <a href="ConnectionPool.html"><code>ConnectionPool</code></a> object. <a href="ConnectionPool.html#attribute-i-pool_config"><code>pool_config</code></a> is a PoolConfig object which describes database connection information (e.g. adapter, host name, username, password, etc), as well as the maximum size for this <a href="ConnectionPool.html"><code>ConnectionPool</code></a>.</p>

<p>The default <a href="ConnectionPool.html"><code>ConnectionPool</code></a> maximum size is 5.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 251
def initialize(pool_config)
  super()

  @pool_config = pool_config
  @db_config = pool_config.db_config
  @role = pool_config.role
  @shard = pool_config.shard

  @checkout_timeout = db_config.checkout_timeout
  @idle_timeout = db_config.idle_timeout
  @max_connections = db_config.max_connections
  @min_connections = db_config.min_connections
  @max_age = db_config.max_age
  @keepalive = db_config.keepalive

  # This variable tracks the cache of threads mapped to reserved connections, with the
  # sole purpose of speeding up the +connection+ method. It is not the authoritative
  # registry of which thread owns which connection. Connection ownership is tracked by
  # the +connection.owner+ attr on each +connection+ instance.
  # The invariant works like this: if there is mapping of &lt;tt&gt;thread =&gt; conn&lt;/tt&gt;,
  # then that +thread+ does indeed own that +conn+. However, an absence of such
  # mapping does not mean that the +thread+ doesn&#39;t own the said connection. In
  # that case +conn.owner+ attr should be consulted.
  # Access and modification of &lt;tt&gt;@leases&lt;/tt&gt; does not require
  # synchronization.
  @leases = LeaseRegistry.new

  @connections         = []
  @automatic_reconnect = true

  # Connection pool allows for concurrent (outside the main +synchronize+ section)
  # establishment of new connections. This variable tracks the number of threads
  # currently in the process of independently establishing connections to the DB.
  @now_connecting = 0

  # Sometimes otherwise-idle connections are temporarily held by the Reaper for
  # maintenance. This variable tracks the number of connections currently in that
  # state -- if a thread requests a connection and there are none available, it
  # will await any in-maintenance connections in preference to creating a new one.
  @maintaining = 0

  @threads_blocking_new_connections = 0

  @available = ConnectionLeasingQueue.new self
  @pinned_connection = nil
  @pinned_connections_depth = 0

  @async_executor = build_async_executor

  @schema_cache = nil

  @activated = false
  @original_context = ActiveSupport::IsolatedExecutionState.context

  @reaper_lock = Monitor.new
  @reaper = Reaper.new(self, db_config.reaping_frequency)
  @reaper.run
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L251" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
      
    
      <h2 id="instance-public-methods">Instance Public methods</h2>
      
        <div class="method">
          <h3 id="method-i-activate">
            
              activate()
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 342
def activate
  @activated = true
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L342" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-activated-3F">
            
              activated?()
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 346
def activated?
  @activated
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L346" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-active_connection-3F">
            
              active_connection?()
            
          </h3>

          
            <div class="description">
              <p>Returns true if there is an open connection being used for the current thread.</p>

<p>This method only works for connections that have been obtained through <a href="ConnectionPool.html#method-i-lease_connection"><code>lease_connection</code></a> or <a href="ConnectionPool.html#method-i-with_connection"><code>with_connection</code></a> methods. Connections obtained through <a href="ConnectionPool.html#method-i-checkout"><code>checkout</code></a> will not be detected by <a href="ConnectionPool.html#method-i-active_connection-3F"><code>active_connection?</code></a></p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 419
def active_connection?
  connection_lease.connection
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L419" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-checkin">
            
              checkin(conn)
            
          </h3>

          
            <div class="description">
              <p>Check-in a database connection back into the pool, indicating that you no longer need this connection.</p>

<p><code>conn</code>: an <a href="AbstractAdapter.html"><code>AbstractAdapter</code></a> object, which was obtained by earlier by calling <a href="ConnectionPool.html#method-i-checkout"><code>checkout</code></a> on this pool.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 658
def checkin(conn)
  return if @pinned_connection.equal?(conn)

  conn.lock.synchronize do
    synchronize do
      connection_lease.clear(conn)
      conn.expire
      @available.add conn
    end
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L658" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-checkout">
            
              checkout(checkout_timeout = @checkout_timeout)
            
          </h3>

          
            <div class="description">
              <p>Check-out a database connection from the pool, indicating that you want to use it. You should call <a href="ConnectionPool.html#method-i-checkin"><code>checkin</code></a> when you no longer need this.</p>

<p>This is done by either returning and leasing existing connection, or by creating a new connection and leasing it.</p>

<p>If all connections are leased and the pool is at capacity (meaning the number of currently leased connections is greater than or equal to the size limit set), an <a href="../ConnectionTimeoutError.html"><code>ActiveRecord::ConnectionTimeoutError</code></a> exception will be raised.</p>

<p>Returns: an <a href="AbstractAdapter.html"><code>AbstractAdapter</code></a> object.</p>

<p>Raises:</p>
<ul><li>
<p><a href="../ConnectionTimeoutError.html"><code>ActiveRecord::ConnectionTimeoutError</code></a> no connection can be obtained from the pool.</p>
</li></ul>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 630
def checkout(checkout_timeout = @checkout_timeout)
  return checkout_and_verify(acquire_connection(checkout_timeout)) unless @pinned_connection

  @pinned_connection.lock.synchronize do
    synchronize do
      # The pinned connection may have been cleaned up before we synchronized, so check if it is still present
      if @pinned_connection
        @pinned_connection.verify!

        # Any leased connection must be in @connections otherwise
        # some methods like #connected? won&#39;t behave correctly
        unless @connections.include?(@pinned_connection)
          @connections &lt;&lt; @pinned_connection
        end

        @pinned_connection
      else
        checkout_and_verify(acquire_connection(checkout_timeout))
      end
    end
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L630" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-clear_reloadable_connections">
            
              clear_reloadable_connections(raise_on_acquisition_timeout = true)
            
          </h3>

          
            <div class="description">
              <p>Clears reloadable connections from the pool and re-connects connections that require reloading.</p>

<p>Raises:</p>
<ul><li>
<p><a href="../ExclusiveConnectionTimeoutError.html"><code>ActiveRecord::ExclusiveConnectionTimeoutError</code></a> if unable to gain ownership of all connections in the pool within a timeout interval (default duration is <code>spec.db_config.checkout_timeout * 2</code> seconds).</p>
</li></ul>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 588
def clear_reloadable_connections(raise_on_acquisition_timeout = true)
  with_exclusively_acquired_all_connections(raise_on_acquisition_timeout) do
    synchronize do
      @connections.each do |conn|
        if conn.in_use?
          conn.steal!
          checkin conn
        end
        conn.disconnect! if conn.requires_reloading?
      end
      @connections.delete_if(&amp;:requires_reloading?)
      @available.clear
    end
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L588" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-clear_reloadable_connections-21">
            
              clear_reloadable_connections!()
            
          </h3>

          
            <div class="description">
              <p>Clears reloadable connections from the pool and re-connects connections that require reloading.</p>

<p>The pool first tries to gain ownership of all connections. If unable to do so within a timeout interval (default duration is <code>spec.db_config.checkout_timeout * 2</code> seconds), then the pool forcefully clears the cache and reloads connections without any regard for other connection owning threads.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 612
def clear_reloadable_connections!
  clear_reloadable_connections(false)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L612" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-connected-3F">
            
              connected?()
            
          </h3>

          
            <div class="description">
              <p>Returns true if a connection has already been opened.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 490
def connected?
  synchronize { @connections.any?(&amp;:connected?) }
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L490" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-connections">
            
              connections()
            
          </h3>

          
            <div class="description">
              <p>Returns an array containing the connections currently in the pool. Access to the array does not require synchronization on the pool because the array is newly created and not retained by the pool.</p>

<p>However; this method bypasses the ConnectionPool’s thread-safe connection access pattern. A returned connection may be owned by another thread, unowned, or by happen-stance owned by the calling thread.</p>

<p>Calling methods on a connection without ownership is subject to the thread-safety guarantees of the underlying method. Many of the methods on connection adapter classes are inherently multi-thread unsafe.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 505
def connections
  synchronize { @connections.dup }
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L505" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-disconnect">
            
              disconnect(raise_on_acquisition_timeout = true)
            
          </h3>

          
            <div class="description">
              <p>Disconnects all connections in the pool, and clears the pool.</p>

<p>Raises:</p>
<ul><li>
<p><a href="../ExclusiveConnectionTimeoutError.html"><code>ActiveRecord::ExclusiveConnectionTimeoutError</code></a> if unable to gain ownership of all connections in the pool within a timeout interval (default duration is <code>spec.db_config.checkout_timeout * 2</code> seconds).</p>
</li></ul>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 515
def disconnect(raise_on_acquisition_timeout = true)
  @reaper_lock.synchronize do
    return if self.discarded?

    with_exclusively_acquired_all_connections(raise_on_acquisition_timeout) do
      synchronize do
        return if self.discarded?
        @connections.each do |conn|
          if conn.in_use?
            conn.steal!
            checkin conn
          end
          conn.disconnect!
        end
        @connections = []
        @leases.clear
        @available.clear

        # Stop maintaining the minimum size until reactivated
        @activated = false
      end
    end
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L515" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-disconnect-21">
            
              disconnect!()
            
          </h3>

          
            <div class="description">
              <p>Disconnects all connections in the pool, and clears the pool.</p>

<p>The pool first tries to gain ownership of all connections. If unable to do so within a timeout interval (default duration is <code>spec.db_config.checkout_timeout * 2</code> seconds), then the pool is forcefully disconnected without any regard for other connection owning threads.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 546
def disconnect!
  disconnect(false)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L546" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-flush">
            
              flush(minimum_idle = @idle_timeout)
            
          </h3>

          
            <div class="description">
              <p>Disconnect all connections that have been idle for at least <code>minimum_idle</code> seconds. Connections currently checked out, or that were checked in less than <code>minimum_idle</code> seconds ago, are unaffected.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 727
def flush(minimum_idle = @idle_timeout)
  return if minimum_idle.nil?

  removed_connections = synchronize do
    return if self.discarded?

    idle_connections = @connections.select do |conn|
      !conn.in_use? &amp;&amp; conn.seconds_idle &gt;= minimum_idle
    end.sort_by { |conn| -conn.seconds_idle } # sort longest idle first

    # Don&#39;t go below our configured pool minimum unless we&#39;re flushing
    # everything
    idles_to_retain =
      if minimum_idle &gt; 0
        @min_connections - (@connections.size - idle_connections.size)
      else
        0
      end

    if idles_to_retain &gt; 0
      idle_connections.pop idles_to_retain
    end

    idle_connections.each do |conn|
      conn.lease

      @available.delete conn
      @connections.delete conn
    end
  end

  removed_connections.each do |conn|
    conn.disconnect!
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L727" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-flush-21">
            
              flush!()
            
          </h3>

          
            <div class="description">
              <p>Disconnect all currently idle connections. Connections currently checked out are unaffected. The pool will stop maintaining its minimum size until it is reactivated (such as by a subsequent checkout).</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 766
def flush!
  reap
  flush(-1)

  # Stop maintaining the minimum size until reactivated
  @activated = false
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L766" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-keep_alive">
            
              keep_alive(threshold = @keepalive)
            
          </h3>

          
            <div class="description">
              <p>Prod any connections that have been idle for longer than the configured keepalive time. This will incidentally verify the connection is still alive, but the main purpose is to show the server (and any intermediate network hops) that we’re still here and using the connection.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 825
def keep_alive(threshold = @keepalive)
  return if threshold.nil?

  sequential_maintenance -&gt; c { (c.seconds_since_last_activity || 0) &gt; c.pool_jitter(threshold) } do |conn|
    # conn.active? will cause some amount of network activity, which is all
    # we need to provide a keepalive signal.
    #
    # If it returns false, the connection is already broken; disconnect,
    # so it can be found and repaired.
    conn.disconnect! unless conn.active?
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L825" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-lease_connection">
            
              lease_connection()
            
          </h3>

          
            <div class="description">
              <p>Retrieve the connection associated with the current thread, or call <a href="ConnectionPool.html#method-i-checkout"><code>checkout</code></a> to obtain one if necessary.</p>

<p><a href="ConnectionPool.html#method-i-lease_connection"><code>lease_connection</code></a> can be called any number of times; the connection is held in a cache keyed by a thread.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 355
def lease_connection
  lease = connection_lease
  lease.connection ||= checkout
  lease.sticky = true
  lease.connection
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L355" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-pool_transaction_isolation_level">
            
              pool_transaction_isolation_level()
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 891
def pool_transaction_isolation_level
  isolation_level_key = &quot;activerecord_pool_transaction_isolation_level_#{db_config.name}&quot;
  ActiveSupport::IsolatedExecutionState[isolation_level_key]
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L891" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-pool_transaction_isolation_level-3D">
            
              pool_transaction_isolation_level=(isolation_level)
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 896
def pool_transaction_isolation_level=(isolation_level)
  isolation_level_key = &quot;activerecord_pool_transaction_isolation_level_#{db_config.name}&quot;
  ActiveSupport::IsolatedExecutionState[isolation_level_key] = isolation_level
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L896" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-preconnect">
            
              preconnect()
            
          </h3>

          
            <div class="description">
              <p>Preconnect all connections in the pool. This saves pool users from having to wait for a connection to be established when first using it after checkout.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 810
def preconnect
  sequential_maintenance -&gt; c { (!c.connected? || !c.verified?) &amp;&amp; c.allow_preconnect } do |conn|
    conn.connect!
  rescue
    # Wholesale rescue: there&#39;s nothing we can do but move on. The
    # connection will go back to the pool, and the next consumer will
    # presumably try to connect again -- which will either work, or
    # fail and they&#39;ll be able to report the exception.
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L810" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-prepopulate">
            
              prepopulate()
            
          </h3>

          
            <div class="description">
              <p>Ensure that the pool contains at least the configured minimum number of connections.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 776
def prepopulate
  need_new_connections = nil

  synchronize do
    return if self.discarded?

    # We don&#39;t want to start prepopulating until we know the pool is wanted,
    # so we can avoid maintaining full pools in one-off scripts etc.
    return unless @activated

    need_new_connections = @connections.size &lt; @min_connections
  end

  if need_new_connections
    while new_conn = try_to_checkout_new_connection { @connections.size &lt; @min_connections }
      new_conn.allow_preconnect = true
      checkin(new_conn)
    end
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L776" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-reap">
            
              reap()
            
          </h3>

          
            <div class="description">
              <p>Recover lost connections for the pool. A lost connection can occur if a programmer forgets to checkin a connection at the end of a thread or a thread dies unexpectedly.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 704
def reap
  stale_connections = synchronize do
    return if self.discarded?
    @connections.select do |conn|
      conn.in_use? &amp;&amp; !conn.owner.alive?
    end.each do |conn|
      conn.steal!
    end
  end

  stale_connections.each do |conn|
    if conn.active?
      conn.reset!
      checkin conn
    else
      remove conn
    end
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L704" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-recycle-21">
            
              recycle!()
            
          </h3>

          
            <div class="description">
              <p>Immediately mark all current connections as due for replacement, equivalent to them having reached <a href="ConnectionPool.html#attribute-i-max_age"><code>max_age</code></a> – even if there is no <a href="ConnectionPool.html#attribute-i-max_age"><code>max_age</code></a> configured.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 841
def recycle!
  synchronize do
    return if self.discarded?

    @connections.each do |conn|
      conn.force_retirement
    end
  end

  retire_old_connections
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L841" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-release_connection">
            
              release_connection(existing_lease = nil)
            
          </h3>

          
            <div class="description">
              <p>Signal that the thread is finished with the current connection. <a href="ConnectionPool.html#method-i-release_connection"><code>release_connection</code></a> releases the connection-thread association and returns the connection to the pool.</p>

<p>This method only works for connections that have been obtained through <a href="ConnectionPool.html#method-i-lease_connection"><code>lease_connection</code></a> or <a href="ConnectionPool.html#method-i-with_connection"><code>with_connection</code></a> methods, connections obtained through <a href="ConnectionPool.html#method-i-checkout"><code>checkout</code></a> will not be automatically released.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 431
def release_connection(existing_lease = nil)
  return if self.discarded?

  if conn = connection_lease.release
    checkin conn
    return true
  end
  false
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L431" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-remove">
            
              remove(conn)
            
          </h3>

          
            <div class="description">
              <p>Remove a connection from the connection pool. The connection will remain open and active but will no longer be managed by this pool.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 672
def remove(conn)
  needs_new_connection = false

  synchronize do
    remove_connection_from_thread_cache conn

    @connections.delete conn
    @available.delete conn

    # @available.any_waiting? =&gt; true means that prior to removing this
    # conn, the pool was at its max size (@connections.size == @max_connections).
    # This would mean that any threads stuck waiting in the queue wouldn&#39;t
    # know they could checkout_new_connection, so let&#39;s do it for them.
    # Because condition-wait loop is encapsulated in the Queue class
    # (that in turn is oblivious to ConnectionPool implementation), threads
    # that are &quot;stuck&quot; there are helpless. They have no way of creating
    # new connections and are completely reliant on us feeding available
    # connections into the Queue.
    needs_new_connection = @available.num_waiting &gt; @maintaining
  end

  # This is intentionally done outside of the synchronized section as we
  # would like not to hold the main mutex while checking out new connections.
  # Thus there is some chance that needs_new_connection information is now
  # stale, we can live with that (bulk_make_new_connections will make
  # sure not to exceed the pool&#39;s @max_connections limit).
  bulk_make_new_connections(1) if needs_new_connection
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L672" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-retire_old_connections">
            
              retire_old_connections(max_age = @max_age)
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 797
def retire_old_connections(max_age = @max_age)
  max_age ||= Float::INFINITY

  sequential_maintenance -&gt; c { c.connection_age&amp;.&gt;= c.pool_jitter(max_age) } do |conn|
    # Disconnect, then return the adapter to the pool. Preconnect will
    # handle the rest.
    conn.disconnect!
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L797" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-schema_cache">
            
              schema_cache()
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 317
def schema_cache
  @schema_cache ||= BoundSchemaReflection.new(schema_reflection, self)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L317" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-schema_reflection-3D">
            
              schema_reflection=(schema_reflection)
            
          </h3>

          
            <div class="description">
              
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 321
def schema_reflection=(schema_reflection)
  pool_config.schema_reflection = schema_reflection
  @schema_cache = nil
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L321" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-stat">
            
              stat()
            
          </h3>

          
            <div class="description">
              <p>Returns the connection pool’s usage statistic.</p>

<pre><code>ActiveRecord::Base.connection_pool.stat # =&gt; { size: 15, connections: 1, busy: 1, dead: 0, idle: 0, waiting: 0, checkout_timeout: 5 }
</code></pre>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 864
def stat
  synchronize do
    {
      size: size,
      connections: @connections.size,
      busy: @connections.count { |c| c.in_use? &amp;&amp; c.owner.alive? },
      dead: @connections.count { |c| c.in_use? &amp;&amp; !c.owner.alive? },
      idle: @connections.count { |c| !c.in_use? },
      waiting: num_waiting_in_queue,
      checkout_timeout: checkout_timeout
    }
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L864" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-with_connection">
            
              with_connection(prevent_permanent_checkout: false)
            
          </h3>

          
            <div class="description">
              <p>Yields a connection from the connection pool to the block. If no connection is already checked out by the current thread, a connection will be checked out from the pool, yielded to the block, and then returned to the pool when the block is finished. If a connection has already been checked out on the current thread, such as via <a href="ConnectionPool.html#method-i-lease_connection"><code>lease_connection</code></a> or <a href="ConnectionPool.html#method-i-with_connection"><code>with_connection</code></a>, that existing connection will be the one yielded and it will not be returned to the pool automatically at the end of the block; it is expected that such an existing connection will be properly returned to the pool by the code that checked it out.</p>
            </div>
          

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 450
def with_connection(prevent_permanent_checkout: false)
  lease = connection_lease
  sticky_was = lease.sticky
  lease.sticky = false if prevent_permanent_checkout

  if lease.connection
    begin
      yield lease.connection
    ensure
      lease.sticky = sticky_was if prevent_permanent_checkout &amp;&amp; !sticky_was
    end
  else
    begin
      yield lease.connection = checkout
    ensure
      lease.sticky = sticky_was if prevent_permanent_checkout &amp;&amp; !sticky_was
      release_connection(lease) unless lease.sticky
    end
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L450" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
      
    
  
</div>

    </div>
</div>
