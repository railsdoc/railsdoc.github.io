---
title: ActiveSupport::MessageVerifier
layout: default
---
<div class="main">
    <div class="banner">
        
            <span>Ruby on Rails 8.1.0.rc1</span><br />
        
        <div class="type">Class</div>
        <h1>
            ActiveSupport::MessageVerifier
            
                <span class="parent">&lt;
                    
                    Messages::Codec
                    
                </span>
            
        </h1>
        <ul class="files">
            
            <li><a href="../../files/activesupport/lib/active_support/message_verifier_rb.html">activesupport/lib/active_support/message_verifier.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="class-ActiveSupport::MessageVerifier-label-Active+Support+Message+Verifier">Active Support Message Verifier</h1>

<p><a href="MessageVerifier.html"><code>MessageVerifier</code></a> makes it easy to generate and verify messages which are signed to prevent tampering.</p>

<p>In a Rails application, you can use <a href="../Rails.html#method-c-application"><code>Rails.application.message_verifier</code></a> to manage unique instances of verifiers for each use case. <a href="../Rails/Application.html#method-i-message_verifier">Learn more</a>.</p>

<p>This is useful for cases like remember-me tokens and auto-unsubscribe links where the session store isn’t suitable or available.</p>

<p>First, generate a signed message:</p>

<pre><code>cookies[:remember_me] = Rails.application.message_verifier(:remember_me).generate([@user.id, 2.weeks.from_now])
</code></pre>

<p>Later verify that message:</p>

<pre><code>id, time = Rails.application.message_verifier(:remember_me).verify(cookies[:remember_me])
if time.future?
  self.current_user = User.find(id)
end
</code></pre>

<h3 id="class-ActiveSupport::MessageVerifier-label-Signing+is+not+encryption">Signing is not encryption</h3>

<p>The signed messages are not encrypted. The payload is merely encoded (Base64 by default) and can be decoded by anyone. The signature is just assuring that the message wasn’t tampered with. For example:</p>

<pre><code>message = Rails.application.message_verifier(&#39;my_purpose&#39;).generate(&#39;never put secrets here&#39;)
# =&gt; &quot;BAhJIhtuZXZlciBwdXQgc2VjcmV0cyBoZXJlBjoGRVQ=--a0c1c0827919da5e949e989c971249355735e140&quot;
Base64.decode64(message.split(&quot;--&quot;).first) # no key needed
# =&gt; &#39;never put secrets here&#39;
</code></pre>

<p>If you also need to encrypt the contents, you must use <a href="MessageEncryptor.html"><code>ActiveSupport::MessageEncryptor</code></a> instead.</p>

<h3 id="class-ActiveSupport::MessageVerifier-label-Confine+messages+to+a+specific+purpose">Confine messages to a specific purpose</h3>

<p>It’s not recommended to use the same verifier for different purposes in your application. Doing so could allow a malicious actor to re-use a signed message to perform an unauthorized action. You can reduce this risk by confining signed messages to a specific <code>:purpose</code>.</p>

<pre><code>token = @verifier.generate(&quot;signed message&quot;, purpose: :login)
</code></pre>

<p>Then that same purpose must be passed when verifying to get the data back out:</p>

<pre><code>@verifier.verified(token, purpose: :login)    # =&gt; &quot;signed message&quot;
@verifier.verified(token, purpose: :shipping) # =&gt; nil
@verifier.verified(token)                     # =&gt; nil

@verifier.verify(token, purpose: :login)      # =&gt; &quot;signed message&quot;
@verifier.verify(token, purpose: :shipping)   # =&gt; raises ActiveSupport::MessageVerifier::InvalidSignature
@verifier.verify(token)                       # =&gt; raises ActiveSupport::MessageVerifier::InvalidSignature
</code></pre>

<p>Likewise, if a message has no purpose it won’t be returned when verifying with a specific purpose.</p>

<pre><code>token = @verifier.generate(&quot;signed message&quot;)
@verifier.verified(token, purpose: :redirect) # =&gt; nil
@verifier.verified(token)                     # =&gt; &quot;signed message&quot;

@verifier.verify(token, purpose: :redirect)   # =&gt; raises ActiveSupport::MessageVerifier::InvalidSignature
@verifier.verify(token)                       # =&gt; &quot;signed message&quot;
</code></pre>

<h3 id="class-ActiveSupport::MessageVerifier-label-Expiring+messages">Expiring messages</h3>

<p>By default messages last forever and verifying one year from now will still return the original value. But messages can be set to expire at a given time with <code>:expires_in</code> or <code>:expires_at</code>.</p>

<pre><code>@verifier.generate(&quot;signed message&quot;, expires_in: 1.month)
@verifier.generate(&quot;signed message&quot;, expires_at: Time.now.end_of_year)
</code></pre>

<p><a href="Messages.html"><code>Messages</code></a> can then be verified and returned until expiry. Thereafter, the <code>verified</code> method returns <code>nil</code> while <code>verify</code> raises <a href="MessageVerifier/InvalidSignature.html"><code>ActiveSupport::MessageVerifier::InvalidSignature</code></a>.</p>

<h3 id="class-ActiveSupport::MessageVerifier-label-Rotating+keys">Rotating keys</h3>

<p><a href="MessageVerifier.html"><code>MessageVerifier</code></a> also supports rotating out old configurations by falling back to a stack of verifiers. Call <code>rotate</code> to build and add a verifier so either <code>verified</code> or <code>verify</code> will also try verifying with the fallback.</p>

<p>By default any rotated verifiers use the values of the primary verifier unless specified otherwise.</p>

<p>You’d give your verifier the new defaults:</p>

<pre><code>verifier = ActiveSupport::MessageVerifier.new(@secret, digest: &quot;SHA512&quot;, serializer: JSON)
</code></pre>

<p>Then gradually rotate the old values out by adding them as fallbacks. Any message generated with the old values will then work until the rotation is removed.</p>

<pre><code>verifier.rotate(old_secret)          # Fallback to an old secret instead of @secret.
verifier.rotate(digest: &quot;SHA256&quot;)    # Fallback to an old digest instead of SHA512.
verifier.rotate(serializer: Marshal) # Fallback to an old serializer instead of JSON.
</code></pre>

<p>Though the above would most likely be combined into one rotation:</p>

<pre><code>verifier.rotate(old_secret, digest: &quot;SHA256&quot;, serializer: Marshal)
</code></pre>

    </div>
  

  

  
  


  
    <h2 id="namespace">Namespace</h2>

    

    
      <h3 id="class">Class</h3>
      <ul>
      
        <li><a href="MessageVerifier/InvalidSignature.html">ActiveSupport::MessageVerifier::InvalidSignature</a></li>
      
      </ul>
    
  

  
    <h2 id="methods">Methods</h2>
    <ul>
      
        <li>
          <a href="#method-i-generate">generate</a>
        </li>
      
        <li>
          <a href="#method-c-new">new</a>
        </li>
      
        <li>
          <a href="#method-i-valid_message-3F">valid_message?</a>
        </li>
      
        <li>
          <a href="#method-i-verified">verified</a>
        </li>
      
        <li>
          <a href="#method-i-verify">verify</a>
        </li>
      
    </ul>
  

  

  
    

    

    

    

    <!-- Methods -->
    
      <h2 id="class-public-methods">Class Public methods</h2>
      
        <div class="method">
          <h3 id="method-c-new"><code><b>new</b>(secret, **options)</code></h3>

          <div class="description">
<p>Initialize a new <a href="MessageVerifier.html"><code>MessageVerifier</code></a> with a secret for the signature.</p>

<h4 id="method-c-new-label-Options">Options</h4>
<dl class="rdoc-list label-list"><dt><code>:digest</code></dt>
<dd>
<p><a href="../Digest.html"><code>Digest</code></a> used for signing. The default is <code>&quot;SHA1&quot;</code>. See <code>OpenSSL::Digest</code> for alternatives.</p>
</dd><dt><code>:serializer</code></dt>
<dd>
<p>The serializer used to serialize message data. You can specify any object that responds to <code>dump</code> and <code>load</code>, or you can choose from several preconfigured serializers: <code>:marshal</code>, <code>:json_allow_marshal</code>, <code>:json</code>, <code>:message_pack_allow_marshal</code>, <code>:message_pack</code>.</p>

<p>The preconfigured serializers include a fallback mechanism to support multiple deserialization formats. For example, the <code>:marshal</code> serializer will serialize using <code>Marshal</code>, but can deserialize using <code>Marshal</code>, <a href="JSON.html"><code>ActiveSupport::JSON</code></a>, or <a href="MessagePack.html"><code>ActiveSupport::MessagePack</code></a>. This makes it easy to migrate between serializers.</p>

<p>The <code>:marshal</code>, <code>:json_allow_marshal</code>, and <code>:message_pack_allow_marshal</code> serializers support deserializing using <code>Marshal</code>, but the others do not. Beware that <code>Marshal</code> is a potential vector for deserialization attacks in cases where a message signing secret has been leaked. <em>If possible, choose a serializer that does not support <code>Marshal</code>.</em></p>

<p>The <code>:message_pack</code> and <code>:message_pack_allow_marshal</code> serializers use <a href="MessagePack.html"><code>ActiveSupport::MessagePack</code></a>, which can roundtrip some Ruby types that are not supported by <a href="JSON.html"><code>JSON</code></a>, and may provide improved performance. However, these require the <code>msgpack</code> gem.</p>

<p>When using Rails, the default depends on <code>config.active_support.message_serializer</code>. Otherwise, the default is <code>:marshal</code>.</p>
</dd><dt><code>:url_safe</code></dt>
<dd>
<p>By default, <a href="MessageVerifier.html"><code>MessageVerifier</code></a> generates RFC 4648 compliant strings which are not URL-safe. In other words, they can contain “+” and “/”. If you want to generate URL-safe strings (in compliance with “Base 64 Encoding with URL and Filename Safe Alphabet” in RFC 4648), you can pass <code>true</code>. Note that <a href="MessageVerifier.html"><code>MessageVerifier</code></a> will always accept both URL-safe and URL-unsafe encoded messages, to allow a smooth transition between the two settings.</p>
</dd><dt><code>:force_legacy_metadata_serializer</code></dt>
<dd>
<p>Whether to use the legacy metadata serializer, which serializes the message first, then wraps it in an envelope which is also serialized. This was the default in Rails 7.0 and below.</p>

<p>If you don’t pass a truthy value, the default is set using <code>config.active_support.use_message_serializer_for_metadata</code>.</p>
</dd></dl>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activesupport/lib/active_support/message_verifier.rb, line 167
def initialize(secret, **options)
  raise ArgumentError, &quot;Secret should not be nil.&quot; unless secret
  super(**options)
  @secret = secret
  @digest = options[:digest]&amp;.to_s || &quot;SHA1&quot;
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activesupport/lib/active_support/message_verifier.rb#L167" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
      
    
      <h2 id="instance-public-methods">Instance Public methods</h2>
      
        <div class="method">
          <h3 id="method-i-generate"><code><b>generate</b>(value, **options)</code></h3>

          <div class="description">
<p>Generates a signed message for the provided value.</p>

<p>The message is signed with the <a href="MessageVerifier.html"><code>MessageVerifier</code></a>‘s secret. Returns Base64-encoded message joined with the generated signature.</p>

<pre><code>verifier = ActiveSupport::MessageVerifier.new(&quot;secret&quot;)
verifier.generate(&quot;signed message&quot;) # =&gt; &quot;BAhJIhNzaWduZWQgbWVzc2FnZQY6BkVU--f67d5f27c3ee0b8483cebf2103757455e947493b&quot;
</code></pre>

<h4 id="method-i-generate-label-Options">Options</h4>
<dl class="rdoc-list label-list"><dt><code>:expires_at</code></dt>
<dd>
<p>The datetime at which the message expires. After this datetime, verification of the message will fail.</p>

<pre><code>message = verifier.generate(&quot;hello&quot;, expires_at: Time.now.tomorrow)
verifier.verified(message) # =&gt; &quot;hello&quot;
# 24 hours later...
verifier.verified(message) # =&gt; nil
verifier.verify(message)   # =&gt; raises ActiveSupport::MessageVerifier::InvalidSignature
</code></pre>
</dd><dt><code>:expires_in</code></dt>
<dd>
<p>The duration for which the message is valid. After this duration has elapsed, verification of the message will fail.</p>

<pre><code>message = verifier.generate(&quot;hello&quot;, expires_in: 24.hours)
verifier.verified(message) # =&gt; &quot;hello&quot;
# 24 hours later...
verifier.verified(message) # =&gt; nil
verifier.verify(message)   # =&gt; raises ActiveSupport::MessageVerifier::InvalidSignature
</code></pre>
</dd><dt><code>:purpose</code></dt>
<dd>
<p>The purpose of the message. If specified, the same purpose must be specified when verifying the message; otherwise, verification will fail. (See <a href="MessageVerifier.html#method-i-verified"><code>verified</code></a> and <a href="MessageVerifier.html#method-i-verify"><code>verify</code></a>.)</p>
</dd></dl>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activesupport/lib/active_support/message_verifier.rb, line 306
def generate(value, **options)
  create_message(value, **options)
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activesupport/lib/active_support/message_verifier.rb#L306" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-valid_message-3F"><code><b>valid_message?</b>(message)</code></h3>

          <div class="description">
<p>Checks if a signed message could have been generated by signing an object with the <a href="MessageVerifier.html"><code>MessageVerifier</code></a>‘s secret.</p>

<pre><code>verifier = ActiveSupport::MessageVerifier.new(&quot;secret&quot;)
signed_message = verifier.generate(&quot;signed message&quot;)
verifier.valid_message?(signed_message) # =&gt; true

tampered_message = signed_message.chop # editing the message invalidates the signature
verifier.valid_message?(tampered_message) # =&gt; false
</code></pre>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activesupport/lib/active_support/message_verifier.rb, line 183
def valid_message?(message)
  !!catch_and_ignore(:invalid_message_format) { extract_encoded(message) }
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activesupport/lib/active_support/message_verifier.rb#L183" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-verified"><code><b>verified</b>(message, **options)</code></h3>

          <div class="description">
<p>Decodes the signed message using the <a href="MessageVerifier.html"><code>MessageVerifier</code></a>‘s secret.</p>

<pre><code>verifier = ActiveSupport::MessageVerifier.new(&quot;secret&quot;)

signed_message = verifier.generate(&quot;signed message&quot;)
verifier.verified(signed_message) # =&gt; &quot;signed message&quot;
</code></pre>

<p>Returns <code>nil</code> if the message was not signed with the same secret.</p>

<pre><code>other_verifier = ActiveSupport::MessageVerifier.new(&quot;different_secret&quot;)
other_verifier.verified(signed_message) # =&gt; nil
</code></pre>

<p>Returns <code>nil</code> if the message is not Base64-encoded.</p>

<pre><code>invalid_message = &quot;f--46a0120593880c733a53b6dad75b42ddc1c8996d&quot;
verifier.verified(invalid_message) # =&gt; nil
</code></pre>

<p>Raises any error raised while decoding the signed message.</p>

<pre><code>incompatible_message = &quot;test--dad7b06c94abba8d46a15fafaef56c327665d5ff&quot;
verifier.verified(incompatible_message) # =&gt; TypeError: incompatible marshal file format
</code></pre>

<h4 id="method-i-verified-label-Options">Options</h4>
<dl class="rdoc-list label-list"><dt><code>:purpose</code></dt>
<dd>
<p>The purpose that the message was generated with. If the purpose does not match, <code>verified</code> will return <code>nil</code>.</p>

<pre><code>message = verifier.generate(&quot;hello&quot;, purpose: &quot;greeting&quot;)
verifier.verified(message, purpose: &quot;greeting&quot;) # =&gt; &quot;hello&quot;
verifier.verified(message, purpose: &quot;chatting&quot;) # =&gt; nil
verifier.verified(message)                      # =&gt; nil

message = verifier.generate(&quot;bye&quot;)
verifier.verified(message)                      # =&gt; &quot;bye&quot;
verifier.verified(message, purpose: &quot;greeting&quot;) # =&gt; nil
</code></pre>
</dd></dl>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activesupport/lib/active_support/message_verifier.rb, line 224
def verified(message, **options)
  catch_and_ignore :invalid_message_format do
    catch_and_raise :invalid_message_serialization do
      catch_and_ignore :invalid_message_content do
        read_message(message, **options)
      end
    end
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activesupport/lib/active_support/message_verifier.rb#L224" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
        <div class="method">
          <h3 id="method-i-verify"><code><b>verify</b>(message, **options)</code></h3>

          <div class="description">
<p>Decodes the signed message using the <a href="MessageVerifier.html"><code>MessageVerifier</code></a>‘s secret.</p>

<pre><code>verifier = ActiveSupport::MessageVerifier.new(&quot;secret&quot;)
signed_message = verifier.generate(&quot;signed message&quot;)

verifier.verify(signed_message) # =&gt; &quot;signed message&quot;
</code></pre>

<p>Raises <a href="MessageVerifier/InvalidSignature.html"><code>InvalidSignature</code></a> if the message was not signed with the same secret or was not Base64-encoded.</p>

<pre><code>other_verifier = ActiveSupport::MessageVerifier.new(&quot;different_secret&quot;)
other_verifier.verify(signed_message) # =&gt; ActiveSupport::MessageVerifier::InvalidSignature
</code></pre>

<h4 id="method-i-verify-label-Options">Options</h4>
<dl class="rdoc-list label-list"><dt><code>:purpose</code></dt>
<dd>
<p>The purpose that the message was generated with. If the purpose does not match, <code>verify</code> will raise <a href="MessageVerifier/InvalidSignature.html"><code>ActiveSupport::MessageVerifier::InvalidSignature</code></a>.</p>

<pre><code>message = verifier.generate(&quot;hello&quot;, purpose: &quot;greeting&quot;)
verifier.verify(message, purpose: &quot;greeting&quot;) # =&gt; &quot;hello&quot;
verifier.verify(message, purpose: &quot;chatting&quot;) # =&gt; raises InvalidSignature
verifier.verify(message)                      # =&gt; raises InvalidSignature

message = verifier.generate(&quot;bye&quot;)
verifier.verify(message)                      # =&gt; &quot;bye&quot;
verifier.verify(message, purpose: &quot;greeting&quot;) # =&gt; raises InvalidSignature
</code></pre>
</dd></dl>
</div>

          

          

          
          
            <details class="method__source">
              <summary>
                <span class="label">📝 Source code</span>
              </summary>

              <pre><code class="ruby"># File activesupport/lib/active_support/message_verifier.rb, line 262
def verify(message, **options)
  catch_and_raise :invalid_message_format, as: InvalidSignature do
    catch_and_raise :invalid_message_serialization do
      catch_and_raise :invalid_message_content, as: InvalidSignature do
        read_message(message, **options)
      end
    end
  end
end</code></pre>
              
                <a href="https://github.com/rails/rails/blob/4720fe9c00605d6ad2d50904e98a4d5522ffbce2/activesupport/lib/active_support/message_verifier.rb#L262" target="_blank" class="github_url">🔎 See on GitHub</a>
              
            </details>
          
        </div>
        
      
    
  
</div>

    </div>
</div>
